import supabase from '../lib/supabase.js'
import { messages } from '../lib/i18n.js'
import { sendTelegramMessage, assertTelegramSecret, parsePercentageInput, parseAmountInput, normalizePhoneE164, validateEmail, formatTemplate, answerCallbackQuery, editMessageText } from '../lib/helpers.js'
import { getOrCreateUserByTelegram, getState, setState, clearState, getStepDescription } from '../lib/state.js'
import { triggerDailySummaryUpdate } from '../lib/daily-summary.js'

const GROUP_CATEGORIES = {
  A: [
    ['é¤é¥®', 'é¤é¥®'], ['å¨±ä¹', 'å¨±ä¹'], ['è´­ç‰©', 'è´­ç‰©'], ['äº¤é€š', 'äº¤é€š'], ['æ°´ç”µ', 'æ°´ç”µ'], ['æ‰‹æœº', 'æ‰‹æœº'], ['å®¶ç”¨', 'å®¶ç”¨'], ['å…¶ä»–', 'å…¶ä»–']
  ],
  B: [
    ['ä¹¦ç±', 'ä¹¦ç±'], ['è¯¾ç¨‹', 'è¯¾ç¨‹'], ['åŸ¹è®­', 'åŸ¹è®­'], ['è®¤è¯', 'è®¤è¯']
  ],
  C: [
    ['è‚¡ç¥¨', 'è‚¡ç¥¨'], ['å®šå­˜', 'å®šå­˜'], ['ä¿é™©', 'ä¿é™©'], ['ç´§æ€¥åŸºé‡‘', 'ç´§æ€¥åŸºé‡‘'], ['å…¶ä»–', 'å…¶ä»–']
  ]
}

// æ£€æŸ¥æ˜¯å¦ä¸ºè‡ªåŠ¨ç”Ÿæˆçš„é¡¹ç›®
function isAutoGeneratedRecord(categoryCode) {
  return categoryCode && (
    categoryCode.includes('_auto') || 
    categoryCode === 'travel_auto' ||
    categoryCode === 'ins_med_auto' ||
    categoryCode === 'ins_car_auto'
  )
}

// æ™ºèƒ½åˆ†ç±»ç®—æ³•
function smartCategorize(input, group) {
  // ç›´æ¥ä½¿ç”¨ç°æœ‰çš„åˆ†ç±»ç³»ç»Ÿ
  const categories = GROUP_CATEGORIES[group] || []
  
  // æ™ºèƒ½åŒ¹é…é€»è¾‘ï¼šåŒ¹é…åˆ†ç±»æ ‡ç­¾
  for (const [code, label] of categories) {
    if (input.toLowerCase().includes(label.toLowerCase())) {
      return { group, code }
    }
  }
  
  // å¦‚æœéƒ½ä¸åŒ¹é…ï¼Œå½’åˆ°"å…¶ä»–"ï¼ˆå¦‚æœè¯¥ç»„æœ‰"å…¶ä»–"åˆ†ç±»ï¼‰
  const hasOther = categories.some(([code]) => code === 'other')
  if (hasOther) {
    return { group, code: 'other' }
  }
  
  // å¦‚æœæ²¡æœ‰"å…¶ä»–"åˆ†ç±»ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ªåˆ†ç±»ä½œä¸ºé»˜è®¤
  const defaultCategory = categories[0]
  if (defaultCategory) {
    return { group, code: defaultCategory[0] }
  }
  
  // æœ€åçš„fallback
  return { group, code: 'other' }
}

// ç”Ÿæˆå†å²è®°å½•æŒ‰é’®
function generateHistoryButtons(row, grpName, catLabel) {
  if (isAutoGeneratedRecord(row.category_code)) {
    // è‡ªåŠ¨è®¡ç®—çš„é¡¹ç›®åªæ˜¾ç¤ºæŸ¥çœ‹ï¼Œä¸å¯ç¼–è¾‘
    return [
      { text: `ğŸ“‹ ${grpName(row.category_group)}Â·${catLabel(row.category_group, row.category_code)} RM ${Number(row.amount).toFixed(0)}`, callback_data: `hist:view:${row.id}` },
      { text: 'ğŸ”’ ç³»ç»Ÿç”Ÿæˆ', callback_data: 'hist:locked' }
    ]
  } else {
    // ç”¨æˆ·æ‰‹åŠ¨è®°å½•çš„é¡¹ç›®å¯ä»¥ç¼–è¾‘
    return [
      { text: `âœï¸ ${grpName(row.category_group)}Â·${catLabel(row.category_group, row.category_code)} RM ${Number(row.amount).toFixed(0)}`, callback_data: `hist:edit:${row.id}` },
      { text: 'ğŸ—‘ åˆ é™¤', callback_data: `hist:del:${row.id}` }
    ]
  }
}

const BRANCH_CODES = [
  'PJY','BLS','OTK','PU','UKT','TLK','M2','BP','MTK','HQ','VIVA','STL','SRD','PDMR','KK'
]

// æ ¼å¼åŒ–åˆ†ç±»æ˜ç»†
// æå– /my å‘½ä»¤æ ¸å¿ƒé€»è¾‘ä¸ºç‹¬ç«‹å‡½æ•°
async function executeMyCommand(chatId, from, req, res) {
  console.log('ğŸ” executeMyCommand å¼€å§‹æ‰§è¡Œï¼Œç”¨æˆ·ID:', from.id, 'èŠå¤©ID:', chatId)
  
  try {
    // 1. æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯
    console.log('ğŸ“Š æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯...')
    const { data: u, error: uErr } = await supabase.from('users').select('id').eq('telegram_id', from.id).single()
    console.log('ç”¨æˆ·æŸ¥è¯¢ç»“æœ:', { user: u, error: uErr })
    
    if (uErr) { 
      console.log('âŒ ç”¨æˆ·æŸ¥è¯¢å¤±è´¥:', uErr)
      await sendTelegramMessage(chatId, messages.my.need_start); 
      return res.status(200).json({ ok: true }) 
    }
    
    // 2. æ„å»º API URL
    console.log('ğŸ”— æ„å»º API URL...')
    const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
    const base = `${url.protocol}//${url.host}`
    console.log('API åŸºç¡€ URL:', base)
    
    // 3. è°ƒç”¨ /api/user/user-system æ¥å£
    console.log('ğŸ“¡ è°ƒç”¨ /api/user/user-system æ¥å£...')
    const r = await fetch(`${base}/api/user/user-system`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'get-summary', userId: u.id })
    })
    console.log('API å“åº”çŠ¶æ€:', r.status, r.ok)
    
    const data = await r.json()
    console.log('API è¿”å›æ•°æ®:', data)
    
    if (!r.ok) { 
      console.log('âŒ API è°ƒç”¨å¤±è´¥:', data)
      await sendTelegramMessage(chatId, 'æŸ¥è¯¢å¤±è´¥'); 
      return res.status(200).json({ ok: true }) 
    }
    
    // ç›´æ¥ä½¿ç”¨ user-system è¿”å›çš„æ ¼å¼åŒ–æ¶ˆæ¯
    const msg = data.msg || 'æ•°æ®è·å–å¤±è´¥'
    
    console.log('ä½¿ç”¨APIè¿”å›çš„æ ¼å¼åŒ–æ¶ˆæ¯ï¼Œæ¶ˆæ¯é•¿åº¦:', msg.length)
    
    // ç”Ÿæˆå…·ä½“çš„æœˆä»½æ ‡é¢˜
    console.log('ğŸ“… ç”Ÿæˆæœˆä»½æ ‡é¢˜...')
    const monthTitle = generateMonthTitle('month')
    const finalMsg = msg.replace('ğŸ“Š month æ•°æ®æ€»è§ˆ', monthTitle)
    
    // å‘é€æ¶ˆæ¯
    console.log('ğŸ“¤ å‘é€æ¶ˆæ¯...')
    await sendTelegramMessage(chatId, finalMsg)
    
    console.log('âœ… executeMyCommand æ‰§è¡ŒæˆåŠŸ')
    return res.status(200).json({ ok: true })
    
  } catch (error) {
    console.error('âŒ executeMyCommand æ‰§è¡Œå¼‚å¸¸:', error)
    console.error('é”™è¯¯å †æ ˆ:', error.stack)
    
    try {
      await sendTelegramMessage(chatId, 'ç³»ç»Ÿé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•')
    } catch (sendError) {
      console.error('å‘é€é”™è¯¯æ¶ˆæ¯ä¹Ÿå¤±è´¥äº†:', sendError)
    }
    
    return res.status(200).json({ ok: true })
  }
}

function formatCategoryDetails(categoryBreakdown, monthlyIncome = 0, epf = 0, balance = 0) {
  if (!categoryBreakdown || Object.keys(categoryBreakdown).length === 0) {
    return 'ï¼ˆæš‚æ— è®°å½•ï¼‰'
  }
  
  const groupLabels = { 'A': 'å¼€é”€', 'B': 'å­¦ä¹ ', 'C': 'å‚¨è“„' }
  const categoryLabels = {
    'A': { 'é¤é¥®': 'é¤é¥®', 'å¨±ä¹': 'å¨±ä¹', 'è´­ç‰©': 'è´­ç‰©', 'äº¤é€š': 'äº¤é€š', 'æ°´ç”µ': 'æ°´ç”µ', 'æ‰‹æœº': 'æ‰‹æœº', 'å®¶ç”¨': 'å®¶ç”¨', 'å…¶ä»–': 'å…¶ä»–' },
    'B': { 'ä¹¦ç±': 'ä¹¦ç±', 'è¯¾ç¨‹': 'è¯¾ç¨‹', 'åŸ¹è®­': 'åŸ¹è®­', 'è®¤è¯': 'è®¤è¯', 'travel_auto': 'æ—…æ¸¸åŸºé‡‘ï¼ˆæœˆï¼‰' },
    'C': { 'è‚¡ç¥¨': 'è‚¡ç¥¨', 'å®šå­˜': 'å®šå­˜', 'ä¿é™©': 'ä¿é™©', 'ç´§æ€¥åŸºé‡‘': 'ç´§æ€¥åŸºé‡‘', 'å…¶ä»–': 'å…¶ä»–', 'ins_med_auto': 'åŒ»ç–—ä¿é™©ï¼ˆæœˆï¼‰', 'ins_car_auto': 'è½¦é™©ï¼ˆæœˆï¼‰', 'epf_auto': 'EPFï¼ˆæœˆï¼‰' }
  }
  
  let result = ''
  
  // è®¡ç®—å„ç»„æ€»é‡‘é¢ï¼ˆä¸åŒ…å«EPFå’Œä½™é¢ï¼‰
  const groupTotals = {}
  for (const [group, categories] of Object.entries(categoryBreakdown)) {
    groupTotals[group] = Object.values(categories).reduce((sum, amount) => sum + Number(amount), 0)
  }
  
  // è®¡ç®—å®é™…æ€»å¼€é”€ï¼ˆA + B + Cï¼‰
  const actualTotalSpent = (groupTotals['A'] || 0) + (groupTotals['B'] || 0) + (groupTotals['C'] || 0)
  
  // è®¡ç®—å‚¨è“„ç»„æœ€ç»ˆæ€»é¢ï¼ˆåŒ…å«EPFå’Œä½™é¢ï¼‰
  let finalSavingsTotal = groupTotals['C'] || 0
  if (epf > 0) {
    finalSavingsTotal += epf
  }
  if (balance > 0) {
    finalSavingsTotal += balance
  }
  
  // å¼ºåˆ¶é‡æ–°åˆ†é…ç™¾åˆ†æ¯”ï¼Œç¡®ä¿æ€»å’Œä¸º100%
  // å¼€é”€ç»„ç™¾åˆ†æ¯”ï¼ˆå›ºå®šï¼‰
  const groupAPercentage = ((groupTotals['A'] || 0) / monthlyIncome) * 100
  // å­¦ä¹ ç»„ç™¾åˆ†æ¯”ï¼ˆå›ºå®šï¼‰
  const groupBPercentage = ((groupTotals['B'] || 0) / monthlyIncome) * 100
  // å‚¨è“„ç»„ç™¾åˆ†æ¯”ï¼ˆè‡ªåŠ¨è®¡ç®—ï¼Œç¡®ä¿æ€»å’Œä¸º100%ï¼‰
  const groupCPercentage = Math.max(0, 100 - groupAPercentage - groupBPercentage)
  
  // æ›´æ–°å‚¨è“„ç»„æ€»é¢ä»¥åŒ¹é…ç›®æ ‡ç™¾åˆ†æ¯”ï¼Œä½†ä¿æŒEPFå’Œä½™é¢çš„æ˜ç»†æ˜¾ç¤º
  const calculatedSavingsTotal = (groupCPercentage / 100) * monthlyIncome
  groupTotals['C'] = calculatedSavingsTotal
  
  console.log('ç™¾åˆ†æ¯”é‡æ–°åˆ†é…:', {
    groupA: groupAPercentage.toFixed(1) + '%',
    groupB: groupBPercentage.toFixed(1) + '%', 
    groupC: groupCPercentage.toFixed(1) + '%',
    total: (groupAPercentage + groupBPercentage + groupCPercentage).toFixed(1) + '%'
  })
  
  for (const [group, categories] of Object.entries(categoryBreakdown)) {
    const groupLabel = groupLabels[group] || group
    let groupTotal = groupTotals[group] || 0
    
    // å¯¹äºå‚¨è“„ç»„ï¼Œç¡®ä¿åŒ…å« EPF å’Œä½™é¢
    if (group === 'C') {
      groupTotal = groupTotals['C'] || 0 // ä½¿ç”¨æ›´æ–°åçš„å‚¨è“„ç»„æ€»é¢
    }
    
    // è®¡ç®—ç»„å æœˆæ”¶å…¥çš„ç™¾åˆ†æ¯”ï¼ˆåŸºäºæœˆæ”¶å…¥ï¼‰
    let groupPercentage = ''
    if (monthlyIncome > 0) {
      groupPercentage = `ï¼ˆ${((groupTotal / monthlyIncome) * 100).toFixed(1)}%ï¼‰`
    }
    
    result += `\n${groupLabel}${groupPercentage}ï¼š\n`
    
    // è®¡ç®—æ¯ä¸ªåˆ†ç±»å æœˆæ”¶å…¥çš„ç™¾åˆ†æ¯”ï¼ˆåŸºäºæœˆæ”¶å…¥ï¼‰
    for (const [code, amount] of Object.entries(categories)) {
      const categoryLabel = categoryLabels[group]?.[code] || code
      const categoryAmount = Number(amount)
      const categoryPercentage = monthlyIncome > 0 ? ((categoryAmount / monthlyIncome) * 100).toFixed(1) : '0.0'
      
      result += `  â€¢ ${categoryLabel}ï¼ˆ${categoryPercentage}%ï¼‰ï¼šRM ${categoryAmount.toFixed(2)}\n`
    }
    
    // å¦‚æœæ˜¯å‚¨è“„ç»„ï¼Œæ·»åŠ EPFå’Œä½™é¢ä¿¡æ¯ï¼Œå¹¶è®¡ç®—è°ƒæ•´åçš„ä½™é¢
    if (group === 'C') {
      // æ˜¾ç¤ºEPF
      if (epf > 0) {
        const epfPercentage = monthlyIncome > 0 ? ((epf / monthlyIncome) * 100).toFixed(1) : '0.0'
        result += `  â€¢ EPFï¼ˆæœˆï¼‰ï¼ˆ${epfPercentage}%ï¼‰ï¼šRM ${epf.toFixed(2)}\n`
      }
      
      // è®¡ç®—è°ƒæ•´åçš„ä½™é¢ï¼ˆæ€»å‚¨è“„ - åŸæœ‰å‚¨è“„é¡¹ç›® - EPFï¼‰
      const originalSavings = Object.values(categories).reduce((sum, amount) => sum + Number(amount), 0)
      const adjustedBalance = groupTotal - originalSavings - epf
      
      // æ˜¾ç¤ºè°ƒæ•´åçš„ä½™é¢
      if (adjustedBalance > 0) {
        const adjustedBalancePercentage = monthlyIncome > 0 ? ((adjustedBalance / monthlyIncome) * 100).toFixed(1) : '0.0'
        result += `  â€¢ ä½™é¢ï¼ˆ${adjustedBalancePercentage}%ï¼‰ï¼šRM ${adjustedBalance.toFixed(2)}\n`
      }
    }
  }
  
  // æ·»åŠ æ€»è®¡ä¿¡æ¯
  if (monthlyIncome > 0) {
    // è®¡ç®—æœ€ç»ˆæ€»è®¡ï¼ˆåŒ…å«EPFå’Œä½™é¢ï¼‰
    const finalTotal = (groupTotals['A'] || 0) + (groupTotals['B'] || 0) + groupTotals['C']
    const totalPercentage = ((finalTotal / monthlyIncome) * 100).toFixed(1)
    result += `\nğŸ“Š æ€»è®¡ï¼šRM ${finalTotal.toFixed(2)}ï¼ˆ${totalPercentage}% æœˆæ”¶å…¥ï¼‰`
  }
  
  return result.trim()
}

// æ ¼å¼åŒ–å®æ—¶å¼€é”€å æ¯”æ˜¾ç¤º
function formatRealtimePercentages(realtimeData) {
  const ra = realtimeData?.a == null ? 'N/A' : realtimeData.a
  const rb = realtimeData?.b == null ? 'N/A' : realtimeData.b
  const rc = realtimeData?.c == null ? 'N/A' : realtimeData.c
  return { ra, rb, rc }
}

// æ ¼å¼åŒ–é¢„ç®—é¢åº¦å‰©ä½™æ˜¾ç¤º
function formatBudgetGap(capA, totalA) {
  const aGap = (Number(capA) - Number(totalA)).toFixed(2)
  const aGapAmount = Number(aGap)
  
  if (aGapAmount >= 0) {
    return `å‰©ä½™é¢åº¦ RM ${aGap}`
  } else {
    return `å·²è¶…å‡º RM ${Math.abs(aGapAmount).toFixed(2)}`
  }
}

function groupKeyboard() {
  return { inline_keyboard: [[
    { text: 'å¼€é”€', callback_data: 'rec:grp:A' },
    { text: 'å­¦ä¹ ', callback_data: 'rec:grp:B' },
    { text: 'å‚¨è“„', callback_data: 'rec:grp:C' }
  ]] }
}

function categoryKeyboard(group) {
  const items = GROUP_CATEGORIES[group] || []
  const rows = []
  for (let i = 0; i < items.length; i += 2) {
    const row = []
    for (let j = i; j < Math.min(i + 2, items.length); j++) {
      const [code, label] = items[j]
      row.push({ text: label, callback_data: `rec:cat:${code}` })
    }
    rows.push(row)
  }
  
  // æ·»åŠ æ‰¹é‡è®°å½•æŒ‰é’®
  rows.push([{ text: 'ğŸ”„ æ‰¹é‡è®°å½•', callback_data: `rec:batch:${group}` }])
  
  return { inline_keyboard: rows }
}

function branchKeyboard() {
  const rows = []
  for (let i = 0; i < BRANCH_CODES.length; i += 3) {
    const row = []
    for (let j = i; j < Math.min(i + 3, BRANCH_CODES.length); j++) {
      const code = BRANCH_CODES[j]
      row.push({ text: code, callback_data: `start:branch:${code}` })
    }
    rows.push(row)
  }
  return { inline_keyboard: rows }
}

function settingsBranchKeyboard() {
  const rows = []
  for (let i = 0; i < BRANCH_CODES.length; i += 3) {
    const row = []
    for (let j = i; j < Math.min(i + 3, BRANCH_CODES.length); j++) {
      const code = BRANCH_CODES[j]
      row.push({ text: code, callback_data: `set:branch:${code}` })
    }
    rows.push(row)
  }
  return { inline_keyboard: rows }
}

async function tryPostMonthlyAlloc(userId, group, category, amount) {
  try {
    const today = new Date()
    const ymd = `${today.toISOString().slice(0,7)}-01`
    
    // EPFå›ºå®šä¸º24%
    const epfPct = 24
    
    // å¹‚ç­‰ï¼šåŒæœˆåŒç±»åˆ«å­˜åœ¨åˆ™è·³è¿‡ï¼ˆä¸¥æ ¼æ£€æŸ¥ ymd+category_codeï¼‰
    const { data: exist } = await supabase
      .from('records')
      .select('id')
      .eq('user_id', userId)
      .eq('ymd', ymd)
      .eq('category_code', category)
      .eq('is_voided', false)
      .maybeSingle()
    
    if (!exist) {
      await supabase.from('records').insert([{ 
        user_id: userId, 
        category_group: group, 
        category_code: category, 
        amount, 
        note: 'Auto-post', 
        ymd 
      }])
      
      // å¼‚æ­¥æ›´æ–°daily summary
      triggerDailySummaryUpdate(userId, ymd)
    }
  } catch (error) {
    console.error('tryPostMonthlyAlloc error:', error)
  }
}

export default async function handler(req, res) {
  if (req.method !== 'POST') return res.status(405).json({ error: 'Method not allowed' })
  if (!assertTelegramSecret(req.headers)) {
    console.error('Bad secret', { expected: !!process.env.TELEGRAM_WEBHOOK_SECRET, got: req.headers['x-telegram-bot-api-secret-token'] || req.headers['X-Telegram-Bot-Api-Secret-Token'] })
    return res.status(401).json({ error: messages.bad_secret })
  }

  try {
    const update = req.body
    // Route callback queries to handler
    if (update && update.callback_query) {
      return handleCallback(update, req, res)
    }
    const msg = update.message || update.edited_message || update.callback_query?.message
    if (!msg) return res.status(200).json({ ok: true })

    const chatId = msg.chat.id
    const from = msg.from
    const text = (msg.text || '').trim()

    if (text.startsWith('/start')) {
      const userId = await getOrCreateUserByTelegram(from, chatId)
      
      // æ£€æŸ¥æ˜¯å¦æœ‰æœªå®Œæˆçš„æ³¨å†Œæµç¨‹
      const existingState = await getState(userId)
      
      if (existingState && existingState.flow === 'start') {
        // æ˜¾ç¤ºçŠ¶æ€æ¢å¤é€‰é¡¹
        const stepDesc = getStepDescription(existingState.step)
        const keyboard = {
          inline_keyboard: [
            [{ text: 'ğŸ”„ ç»§ç»­æ³¨å†Œ', callback_data: 'start:continue' }],
            [{ text: 'âŒ é‡æ–°å¼€å§‹', callback_data: 'start:restart' }]
          ]
        }
        
        await sendTelegramMessage(chatId, 
          `ğŸ“‹ æ£€æµ‹åˆ°æœªå®Œæˆçš„æ³¨å†Œæµç¨‹\n\nå½“å‰è¿›åº¦ï¼š${stepDesc}\n\nè¯·é€‰æ‹©æ“ä½œï¼š`, 
          { reply_markup: keyboard })
        return res.status(200).json({ ok: true })
      }
      
      // å·²æ³¨å†Œçš„åˆ¤å®šï¼šéœ€è¦ç”¨æˆ·ä¸»åŠ¨å®Œæˆè®¾ç½®æµç¨‹
      const { data: prof } = await supabase
        .from('user_profile')
        .select('display_name,monthly_income,a_pct')
        .eq('user_id', userId)
        .maybeSingle()
      
      // æ£€æŸ¥æ˜¯å¦çœŸæ­£å®Œæˆäº†æ³¨å†Œï¼ˆæœ‰æœˆæ”¶å…¥ç­‰å…³é”®ä¿¡æ¯ï¼‰
      const isFullyRegistered = prof && 
        prof.display_name && 
        prof.display_name.trim() && 
        prof.monthly_income && 
        prof.monthly_income > 0 && 
        prof.a_pct && 
        prof.a_pct > 0
      
      if (isFullyRegistered) {
        await sendTelegramMessage(chatId, 'âœ… ä½ å·²å®Œæˆè®¾ç½®ã€‚\nâ€¢ /record - è®°å½•æ”¯å‡º\nâ€¢ /my - æŸ¥çœ‹ç»Ÿè®¡æŠ¥å‘Š\nâ€¢ /settings - ä¿®æ”¹èµ„æ–™')
        return res.status(200).json({ ok: true })
      }
      await setState(userId, 'start', 'nickname', {})
      await sendTelegramMessage(chatId, messages.registration.nickname.prompt)
      return res.status(200).json({ ok: true })
    }
    if (text.startsWith('/settings')) {
      const userId = await getOrCreateUserByTelegram(from, chatId)
      await setState(userId, 'settings', 'choose', {})
  const { data: prof } = await supabase
        .from('user_profile')
        .select('display_name,phone_e164,email,monthly_income,a_pct,travel_budget_annual,annual_medical_insurance,annual_car_insurance')
        .eq('user_id', userId)
        .maybeSingle()
      const { data: urow } = await supabase
        .from('users')
        .select('branch_code')
        .eq('id', userId)
        .maybeSingle()
      const sumText = formatTemplate(messages.settings.summary, {
        nickname: prof?.display_name || '-',
        phone: prof?.phone_e164 || '-',
        email: prof?.email || '-',
        income: (Number(prof?.monthly_income || 0)).toFixed(2),
        a_pct: Number(prof?.a_pct || 0).toFixed(2),
        travel: (Number(prof?.travel_budget_annual || 0)).toFixed(2),
        ins_med: (Number(prof?.annual_medical_insurance || 0)).toFixed(2),
        ins_car: (Number(prof?.annual_car_insurance || 0)).toFixed(2),
        branch: (urow?.branch_code || 'æœªè®¾ç½®')
      })
      const kb = { inline_keyboard: [
        [ { text: messages.settings.fields.nickname, callback_data: 'set:nickname' }, { text: messages.settings.fields.phone, callback_data: 'set:phone' } ],
        [ { text: messages.settings.fields.email, callback_data: 'set:email' }, { text: messages.settings.fields.income, callback_data: 'set:income' } ],
        [ { text: messages.settings.fields.a_pct, callback_data: 'set:a_pct' }, { text: messages.settings.fields.travel, callback_data: 'set:travel' } ],
        [ { text: 'å¹´åº¦åŒ»ç–—ä¿é™©', callback_data: 'set:ins_med' }, { text: 'å¹´åº¦è½¦é™©', callback_data: 'set:ins_car' } ],
        [ { text: messages.settings.fields.branch, callback_data: 'set:branch' } ],
        [ { text: 'âœ… å®Œæˆè®¾ç½®å¹¶ä¿å­˜æ‰€æœ‰ä¿®æ”¹', callback_data: 'set:done' } ]
      ] }
      await sendTelegramMessage(chatId, `${sumText}\n\n${messages.settings.choose}\n\nğŸ’¡ æç¤ºï¼šä¿®æ”¹å®Œæˆåï¼Œè¯·ç‚¹å‡»ä¸‹æ–¹"âœ… å®Œæˆè®¾ç½®å¹¶ä¿å­˜æ‰€æœ‰ä¿®æ”¹"æŒ‰é’®æ¥ç»“æŸè®¾ç½®æµç¨‹ã€‚`, { reply_markup: kb })
      return res.status(200).json({ ok: true })
    }

    if (text.startsWith('/history')) {
      // ç®€åŒ–ï¼š/history å‘½ä»¤ç›´æ¥æ˜¾ç¤ºæœ€è¿‘è®°å½•ï¼Œä¸å†éœ€è¦å‚æ•°
      const { data: u, error: uErr } = await supabase.from('users').select('id').eq('telegram_id', from.id).single()
      if (uErr) { await sendTelegramMessage(chatId, messages.my.need_start); return res.status(200).json({ ok: true }) }
      
      // ç›´æ¥æŸ¥è¯¢æœ€è¿‘çš„è®°å½•ï¼Œä¸ä¾èµ–rangeå‚æ•°
      const { data: records, error: recordsError } = await supabase
        .from('records')
        .select('id,ymd,category_group,category_code,amount,note,created_at')
        .eq('user_id', u.id)
        .eq('is_voided', false)
        .order('ymd', { ascending: false })
        .limit(10)
      
      if (recordsError) { await sendTelegramMessage(chatId, 'æŸ¥è¯¢å¤±è´¥'); return res.status(200).json({ ok: true }) }
      
      const grpName = (g) => g === 'A' ? 'å¼€é”€' : g === 'B' ? 'å­¦ä¹ ' : 'å‚¨è“„'
      const catLabel = (g, code) => {
        // å…ˆæ£€æŸ¥æ˜¯å¦ä¸ºè‡ªåŠ¨ç”Ÿæˆçš„åˆ†ç±»ä»£ç 
        if (code === 'ins_med_auto') return 'åŒ»ç–—ä¿é™©ï¼ˆæœˆï¼‰'
        if (code === 'ins_car_auto') return 'è½¦é™©ï¼ˆæœˆï¼‰'
        if (code === 'epf_auto') return 'EPFï¼ˆæœˆï¼‰'
        if (code === 'travel_auto') return 'æ—…æ¸¸åŸºé‡‘ï¼ˆæœˆï¼‰'
        
        // ç„¶åæ£€æŸ¥å¸¸è§„åˆ†ç±»
        const arr = GROUP_CATEGORIES[g] || []
        const found = arr.find(([c]) => c === code)
        return found ? found[1] : code
      }
      
      const list = (records || []).map(row => {
        const note = row.note && row.note !== 'Auto-post' ? ` Â· ${row.note}` : ''
        return `${row.ymd} Â· ${grpName(row.category_group)}/${catLabel(row.category_group, row.category_code)} Â· RM ${Number(row.amount).toFixed(2)}${note}`
      }).join('\n') || messages.history.noRecords
      
      const rowsKb = (records || []).map(row => generateHistoryButtons(row, grpName, catLabel))
      
      // æ£€æŸ¥æ˜¯å¦æœ‰æ›´å¤šè®°å½•
      const { count: totalCount } = await supabase
        .from('records')
        .select('*', { count: 'exact', head: true })
        .eq('user_id', u.id)
        .eq('is_voided', false)
      
      const hasMore = totalCount > 10
      const kb = { inline_keyboard: [
        ...rowsKb,
        ...(hasMore ? [[{ text: 'ğŸ“„ æŸ¥çœ‹æ›´å¤šè®°å½•', callback_data: 'history:more' }]] : [])
      ] }
      await sendTelegramMessage(chatId, `ğŸ§¾ æœ€è¿‘è®°å½•\n${list}\n\n${messages.history.hint}`, { reply_markup: kb })
      return res.status(200).json({ ok: true })
    }

    if (text.startsWith('/record')) {
      const userId = await getOrCreateUserByTelegram(from, chatId)
      await setState(userId, 'record', 'choose_group', {})
      await sendTelegramMessage(chatId, messages.record.choose_group, { reply_markup: groupKeyboard() })
      return res.status(200).json({ ok: true })
    }

    if (text.startsWith('/my')) {
      // ä½¿ç”¨ç»Ÿä¸€çš„ executeMyCommand å‡½æ•°
      return await executeMyCommand(chatId, from, req, res)
    }
    
    if (false && text.startsWith('/my')) {
      console.log('ğŸ” /my å‘½ä»¤å¼€å§‹æ‰§è¡Œï¼Œç”¨æˆ·ID:', from.id, 'èŠå¤©ID:', chatId)
      
      try {
        // 1. æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯
        console.log('ğŸ“Š æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯...')
        const { data: u, error: uErr } = await supabase.from('users').select('id').eq('telegram_id', from.id).single()
        console.log('ç”¨æˆ·æŸ¥è¯¢ç»“æœ:', { user: u, error: uErr })
        
        if (uErr) { 
          console.log('âŒ ç”¨æˆ·æŸ¥è¯¢å¤±è´¥:', uErr)
          await sendTelegramMessage(chatId, messages.my.need_start); 
          return res.status(200).json({ ok: true }) 
        }
        
        // 2. æ„å»º API URL
        console.log('ğŸ”— æ„å»º API URL...')
        const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
        const base = `${url.protocol}//${url.host}`
        console.log('API åŸºç¡€ URL:', base)
        
        // 3. è°ƒç”¨ /api/user/user-system æ¥å£
        console.log('ğŸ“¡ è°ƒç”¨ /api/user/user-system æ¥å£...')
        const r = await fetch(`${base}/api/user/user-system`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ action: 'get-summary', userId: u.id })
        })
        console.log('API å“åº”çŠ¶æ€:', r.status, r.ok)
        
        const data = await r.json()
        console.log('API è¿”å›æ•°æ®:', data)
        
        if (!r.ok) { 
          console.log('âŒ API è°ƒç”¨å¤±è´¥:', data)
          await sendTelegramMessage(chatId, 'æŸ¥è¯¢å¤±è´¥'); 
          return res.status(200).json({ ok: true }) 
        }
        
        // 4. å¤„ç†æ•°æ®
        console.log('ğŸ”§ å¤„ç†æ•°æ®...')
        
        // å®‰å…¨åœ°è·å–æ•°æ®ï¼Œæä¾›é»˜è®¤å€¼
        const progress = data.progress || {}
        const realtime = data.realtime || {}
        const snapshotView = data.snapshotView || {}
        const totals = data.totals || {}
        const display = data.display || {}
        const categoryBreakdown = data.categoryBreakdown || {}
        
        const a = progress.a ?? 0
        const b = progress.b ?? 0
        const c = progress.c ?? 0
        
        // å®‰å…¨åœ°è°ƒç”¨è¾…åŠ©å‡½æ•°
        const { ra, rb, rc } = formatRealtimePercentages(realtime)
        
        // å®‰å…¨åœ°è®¡ç®—åå·®
        let da = 'N/A'
        if (realtime.a != null && snapshotView.a_pct != null) {
          da = (Number(realtime.a) - Number(snapshotView.a_pct)).toFixed(0)
        }
        
        // å®‰å…¨åœ°è®¡ç®—é¢„ç®—é¢åº¦
        let aGapLine = 'N/A'
        if (snapshotView.cap_a != null && totals.a != null) {
          aGapLine = formatBudgetGap(snapshotView.cap_a, totals.a)
        }
        
        console.log('æ•°æ®å¤„ç†ç»“æœ:', { a, b, c, ra, rb, rc, da, aGapLine })
        console.log('æ•°æ®æºçŠ¶æ€:', { 
          hasProgress: !!data.progress, 
          hasRealtime: !!data.realtime, 
          hasSnapshotView: !!data.snapshotView, 
          hasTotals: !!data.totals, 
          hasDisplay: !!data.display, 
          hasCategoryBreakdown: !!data.categoryBreakdown 
        })
        
        // 5. æ¸²æŸ“æ¨¡æ¿
        console.log('ğŸ“ æ¸²æŸ“æ¨¡æ¿...')
        
        // å®‰å…¨åœ°å‡†å¤‡æ¨¡æ¿å‚æ•°
        const templateParams = {
          range: 'month',
          a: display.a || totals.a?.toFixed(2) || '0.00',
          b: display.b || totals.b?.toFixed(2) || '0.00',
          c: display.c_residual || totals.c?.toFixed(2) || '0.00',
          ra, rb, rc,
          a_pct: snapshotView.a_pct || 0,
          da,
          a_gap_line: aGapLine,
          income: snapshotView.income || '0.00',
          cap_a: snapshotView.cap_a || '0.00',
          cap_b: snapshotView.cap_b || '0.00',
          cap_c: snapshotView.cap_c || '0.00',
          epf: snapshotView.epf || '0.00',
          travel: Number(snapshotView.travelMonthly || 0).toFixed(2),
          medical: Number(snapshotView.medicalMonthly || 0).toFixed(2),
          car_insurance: Number(snapshotView.carInsuranceMonthly || 0).toFixed(2),
          category_details: formatCategoryDetails(categoryBreakdown, Number(snapshotView.income || 0), Number(snapshotView.epf || 0), Number(data.balance || 0))
        }
        
        console.log('æ¨¡æ¿å‚æ•°:', templateParams)
        
        // ç›´æ¥ä½¿ç”¨ user-system è¿”å›çš„æ ¼å¼åŒ–æ¶ˆæ¯
        const msg = data.msg || 'æ•°æ®è·å–å¤±è´¥'
        
        console.log('ä½¿ç”¨APIè¿”å›çš„æ ¼å¼åŒ–æ¶ˆæ¯ï¼Œæ¶ˆæ¯é•¿åº¦:', msg.length)
        
        // 6. ç”Ÿæˆå…·ä½“çš„æœˆä»½æ ‡é¢˜
        console.log('ğŸ“… ç”Ÿæˆæœˆä»½æ ‡é¢˜...')
        const monthTitle = generateMonthTitle('month')
        const finalMsg = msg.replace('ğŸ“Š month æ•°æ®æ€»è§ˆ', monthTitle)
        
        // 7. å‘é€æ¶ˆæ¯
        console.log('ğŸ“¤ å‘é€æ¶ˆæ¯...')
        await sendTelegramMessage(chatId, finalMsg)
        
        console.log('âœ… /my å‘½ä»¤æ‰§è¡ŒæˆåŠŸ')
        return res.status(200).json({ ok: true })
        
      } catch (error) {
        console.error('âŒ /my å‘½ä»¤æ‰§è¡Œå¼‚å¸¸:', error)
        console.error('é”™è¯¯å †æ ˆ:', error.stack)
        
        try {
          await sendTelegramMessage(chatId, 'ç³»ç»Ÿé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•')
        } catch (sendError) {
          console.error('å‘é€é”™è¯¯æ¶ˆæ¯ä¹Ÿå¤±è´¥äº†:', sendError)
        }
        
        return res.status(200).json({ ok: true })
      }
    }

    if (text.startsWith('/broadcast')) {
      const admins = (process.env.ADMIN_TG_IDS || '').split(',').map(s => s.trim()).filter(Boolean)
      if (!admins.includes(String(from.id))) {
        await sendTelegramMessage(chatId, messages.admin.no_perm)
        return res.status(200).json({ ok: true })
      }
      const content = text.replace('/broadcast', '').trim()
      if (!content) { await sendTelegramMessage(chatId, messages.admin.usage); return res.status(200).json({ ok: true }) }
      const { data: profs } = await supabase.from('user_profile').select('chat_id').not('chat_id', 'is', null)
      const chatIds = (profs || []).map(p => p.chat_id)
      let sent = 0
      for (const cid of chatIds) {
        try { await sendTelegramMessage(cid, content) } catch {}
        sent += 1
        if (sent % 25 === 0) await new Promise(r => setTimeout(r, 1100))
      }
      await sendTelegramMessage(chatId, formatTemplate(messages.admin.sent, { n: sent }))
      return res.status(200).json({ ok: true })
    }

    // å¤„ç† /testpush å‘½ä»¤
    if (text === '/testpush') {
      // æ£€æŸ¥æ˜¯å¦æ˜¯ç®¡ç†å‘˜
      const adminIds = (process.env.ADMIN_TG_IDS || '').split(',').map(s => s.trim()).filter(Boolean)
      const isAdmin = adminIds.includes(from.id.toString())
      
      if (!isAdmin) {
        await sendTelegramMessage(chatId, 'âŒ æƒé™ä¸è¶³\n\nğŸ‘¤ ç”¨æˆ·IDï¼š' + from.id + '\nğŸ”’ çŠ¶æ€ï¼šéç®¡ç†å‘˜\n\nğŸ’¡ æç¤ºï¼šæ‚¨ä¸æ˜¯adminï¼Œæ— æ³•ä½¿ç”¨testpushåŠŸèƒ½\n\nğŸ”§ è§£å†³æ–¹æ¡ˆï¼š\nâ€¢ è”ç³»ç®¡ç†å‘˜è·å–æƒé™\nâ€¢ æˆ–ä½¿ç”¨å…¶ä»–å…¬å¼€æµ‹è¯•åŠŸèƒ½\n\nğŸ“ å¦‚éœ€å¸®åŠ©ï¼Œè¯·è”ç³»ç®¡ç†å‘˜')
        return res.status(200).json({ ok: true })
      }
      
      // å…ˆæ˜¾ç¤ºå½“å‰ç”¨æˆ·çš„æ•°æ®åº“çŠ¶æ€ç”¨äºè°ƒè¯•
      console.log(`[DEBUG] ç”¨æˆ· ${from.id} è¯·æ±‚testpushï¼Œå¼€å§‹è°ƒè¯•åˆ†è¡Œé—®é¢˜...`)
      
      // æŸ¥è¯¢ç”¨æˆ·åœ¨usersè¡¨çš„åˆ†è¡Œè®¾ç½®
      const { data: userData } = await supabase
        .from('users')
        .select('id,branch_code,telegram_id')
        .eq('telegram_id', from.id)
        .maybeSingle()
      
      console.log(`[DEBUG] usersè¡¨æŸ¥è¯¢ç»“æœ:`, userData)
      
      // æŸ¥è¯¢ç”¨æˆ·åœ¨user_profileè¡¨çš„æ•°æ®
      if (userData) {
        const { data: profileData } = await supabase
          .from('user_profile')
          .select('chat_id,user_id')
          .eq('user_id', userData.id)
          .maybeSingle()
        
        console.log(`[DEBUG] user_profileè¡¨æŸ¥è¯¢ç»“æœ:`, profileData)
        console.log(`[DEBUG] å½“å‰chat_id: ${chatId}, profileä¸­çš„chat_id: ${profileData?.chat_id}`)
      }
      
      // æ˜¾ç¤ºæµ‹è¯•é€‰é¡¹
      const testOptions = [
        [{ text: 'ğŸŒ… æ—©æ™¨æ¨é€ (8:00 AM)', callback_data: 'admin:morning' }],
        [{ text: 'ğŸŒ™ æ™šé—´æ¨é€ (10:00 PM)', callback_data: 'admin:evening' }],
        [{ text: 'â° æ–­ç­¾æ¸…é›¶ (2:00 AM)', callback_data: 'admin:break-streaks' }],
        [{ text: 'ğŸ“… æœˆåº¦å…¥è´¦ (æ¯æœˆ1å·)', callback_data: 'admin:monthly' }]
      ]
      
      await sendTelegramMessage(chatId, 
        'ğŸ“ å®é™…æ¨é€åŠŸèƒ½æµ‹è¯•\n\nä»¥ä¸‹åŠŸèƒ½éƒ½æœ‰å¯¹åº”çš„å®šæ—¶ä»»åŠ¡ï¼š\n\nâ° æ‹¬å·å†…ä¸ºè‡ªåŠ¨æ‰§è¡Œæ—¶é—´\nğŸ’¡ æµ‹è¯•ä¼šä½¿ç”¨å’Œcronå®Œå…¨ç›¸åŒçš„é€»è¾‘', 
        { reply_markup: { inline_keyboard: testOptions } }
      )
      return res.status(200).json({ ok: true })
    }

    // å¤„ç† /testpush [action] æ ¼å¼çš„å‘½ä»¤
    if (text.startsWith('/testpush ')) {
      const action = text.split(' ')[1]
      
      // æ£€æŸ¥æ˜¯å¦æ˜¯ç®¡ç†å‘˜
      const adminIds = (process.env.ADMIN_TG_IDS || '').split(',').map(s => s.trim()).filter(Boolean)
      const isAdmin = adminIds.includes(from.id.toString())
      
      if (!isAdmin) {
        await sendTelegramMessage(chatId, 'âŒ æƒé™ä¸è¶³\n\nğŸ‘¤ ç”¨æˆ·IDï¼š' + from.id + '\nğŸ”’ çŠ¶æ€ï¼šéç®¡ç†å‘˜\n\nğŸ’¡ æç¤ºï¼šæ‚¨ä¸æ˜¯adminï¼Œæ— æ³•ä½¿ç”¨testpushåŠŸèƒ½\n\nğŸ”§ è§£å†³æ–¹æ¡ˆï¼š\nâ€¢ è”ç³»ç®¡ç†å‘˜è·å–æƒé™\nâ€¢ æˆ–ä½¿ç”¨å…¶ä»–å…¬å¼€æµ‹è¯•åŠŸèƒ½\n\nğŸ“ å¦‚éœ€å¸®åŠ©ï¼Œè¯·è”ç³»ç®¡ç†å‘˜')
        return res.status(200).json({ ok: true })
      }
      
          // ç›´æ¥æ‰§è¡Œæµ‹è¯•
    await executeAdminTest(chatId, action, from.id, req)
    return res.status(200).json({ ok: true })
    }

    if (text.startsWith('æ”¶å…¥') || text.includes('A%') || text.includes('B%')) {
      // ç®€åŒ–è¾“å…¥è§£æï¼šæ”¶å…¥ Xï¼›A% Yï¼›B% Zï¼›æ—…æ¸¸å¹´é¢ Tï¼›ä¸Šæœˆå¼€é”€ Pï¼›åˆ†è¡Œ CODE
      const kvs = {}
      const segs = text.split(/[ï¼›;\n]/)
      for (const s of segs) {
        const [k, v] = s.split(/[:ï¼š\s]+/)
        if (!k || !v) continue
        kvs[k.trim()] = v.trim()
      }
      const income = parseAmountInput(kvs['æ”¶å…¥']) ?? 0
      const aPct = parsePercentageInput(kvs['A%']) ?? 0
      const bPct = parsePercentageInput(kvs['B%']) ?? 0
      const travel = parseAmountInput(kvs['æ—…æ¸¸å¹´é¢']) ?? 0
      const prev = parseAmountInput(kvs['ä¸Šæœˆå¼€é”€']) ?? 0
      const branch = kvs['åˆ†è¡Œ'] ? kvs['åˆ†è¡Œ'].toUpperCase() : null

      const { data: u, error: uErr } = await supabase.from('users').select('id,branch_code').eq('telegram_id', from.id).maybeSingle()
      if (uErr) throw uErr
      let userId = u?.id
      if (!userId) {
        const { data: newU, error: insUErr } = await supabase
          .from('users')
          .insert([{ telegram_id: from.id, name: from.first_name || from.username || 'user', branch_code: branch || process.env.DEFAULT_BRANCH || 'å¿«ç‚¹è®¾ç½®åˆ†è¡Œ' }])
          .select('id')
          .single()
        if (insUErr) throw insUErr
        userId = newU.id
      } else {
        // åªæœ‰æ˜ç¡®æŒ‡å®šäº†åˆ†è¡Œæ—¶æ‰æ›´æ–°åˆ†è¡Œä¿¡æ¯ï¼Œå¦åˆ™ä¿ç•™ç°æœ‰çš„åˆ†è¡Œè®¾ç½®
        if (branch) {
          await supabase.from('users').update({ branch_code: branch }).eq('id', userId)
        }
      }
      await supabase.from('user_profile').upsert({
        user_id: userId,
        display_name: from.first_name || from.username || 'user',
        chat_id: chatId,
        monthly_income: income,
        a_pct: aPct,
        travel_budget_annual: travel,
        prev_month_spend: prev
      })

      // å†™å½“æœˆå¿«ç…§
      const yyyymm = new Date().toISOString().slice(0,7)
      await supabase.from('user_month_budget').upsert({ 
        user_id: userId, 
        yyyymm, 
        income, 
        a_pct: aPct, 
        // epf_pct å·²ç§»é™¤ï¼Œä½¿ç”¨å›ºå®š24%
      })
      await sendTelegramMessage(chatId, messages.start_saved)
      return res.status(200).json({ ok: true })
    }

    // æ£€æŸ¥æ˜¯å¦æœ‰æœªå®Œæˆçš„æ³¨å†Œæµç¨‹
    const userIdForState = await getOrCreateUserByTelegram(from, chatId)
    const st = await getState(userIdForState)
    
    if (st?.flow === 'start') {
      // å¦‚æœç”¨æˆ·å‘é€å…¶ä»–å‘½ä»¤ï¼Œæç¤ºå®Œæˆæ³¨å†Œ
      if (text.startsWith('/') && text !== '/start') {
        const stepDesc = getStepDescription(st.step)
        await sendTelegramMessage(chatId, 
          `âš ï¸ æ‚¨æ­£åœ¨æ³¨å†Œæµç¨‹ä¸­\n\nå½“å‰è¿›åº¦ï¼š${stepDesc}\n\nè¯·å…ˆå®Œæˆæ³¨å†Œï¼Œæˆ–å‘é€ /start é‡æ–°å¼€å§‹`)
        return res.status(200).json({ ok: true })
      }
      
      // åˆ é™¤äº†é‡å¤çš„è¿›åº¦æ˜¾ç¤ºé€»è¾‘ï¼Œè®©ç”¨æˆ·è¾“å…¥èƒ½ç»§ç»­åˆ°ä¸‹é¢çš„å¤„ç†é€»è¾‘
      // ä¸è¦åœ¨è¿™é‡Œ returnï¼Œè®©æµç¨‹ç»§ç»­åˆ°çœŸæ­£çš„è¾“å…¥å¤„ç†ä»£ç 
    }

    // If user is in state flow=record, handle steps for amount/note
    if (st?.flow === 'record') {
      // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–æµç¨‹çš„çŠ¶æ€å†²çª
      if (st.flow !== 'record') {
        await clearState(userIdForState)
        await sendTelegramMessage(chatId, 'âš ï¸ æ£€æµ‹åˆ°çŠ¶æ€å†²çªï¼Œå·²é‡ç½®çŠ¶æ€ã€‚è¯·é‡æ–°å¼€å§‹è®°å½•ã€‚')
        return res.status(200).json({ ok: true })
      }
      
      if (st.step === 'amount') {
        const amt = parseAmountInput(text)
        if (amt == null) { await sendTelegramMessage(chatId, messages.record.amount_invalid); return res.status(200).json({ ok: true }) }
        const payload = { ...st.payload, amount: amt }
        await setState(userIdForState, 'record', 'note', payload)
        await sendTelegramMessage(chatId, messages.record.note_prompt)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'note') {
        const note = text === '/skip' ? '' : text.slice(0, 200)
        const payload = { ...st.payload, note }
        await setState(userIdForState, 'record', 'confirm', payload)
        const preview = formatTemplate(messages.record.preview, { groupLabel: payload.groupLabel, category: payload.category, amount: payload.amount.toFixed(2), note: note || 'â€”' })
        await sendTelegramMessage(chatId, preview, { reply_markup: { inline_keyboard: [[{ text: 'âœ… ç¡®è®¤', callback_data: 'rec:confirm' }, { text: 'âŒ å–æ¶ˆ', callback_data: 'rec:cancel' }]] } })
        return res.status(200).json({ ok: true })
      }
    }

    // æ‰¹é‡è®°å½•æµç¨‹å¤„ç†
    if (st?.flow === 'batch') {
      
      if (st.step === 'input') {
        // è§£ææ‰¹é‡è¾“å…¥
        const lines = text.split('\n').filter(line => line.trim())
        if (lines.length === 0) {
          await sendTelegramMessage(chatId, 'âŒ è¯·è¾“å…¥è‡³å°‘ä¸€æ¡è®°å½•')
          return res.status(200).json({ ok: true })
        }
        if (lines.length > 20) {
          const errorMessage = 'âŒ å•æ¬¡æœ€å¤šæ”¯æŒ20æ¡è®°å½•ï¼Œè¯·åˆ†æ‰¹è¾“å…¥æˆ–ç‚¹å‡»å–æ¶ˆ'
          const cancelButton = { inline_keyboard: [[{ text: 'âŒ å–æ¶ˆ', callback_data: 'batch:cancel' }]] }
          await sendTelegramMessage(chatId, errorMessage, { reply_markup: cancelButton })
          return res.status(200).json({ ok: true })
        }

        const records = []
        const errors = []
        
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim()
          const parts = line.split(/\s+/)
          
          if (parts.length < 2) {
            errors.push(`ç¬¬${i + 1}è¡Œï¼šæ ¼å¼é”™è¯¯ï¼Œéœ€è¦"åˆ†ç±» é‡‘é¢ å¤‡æ³¨"`)
            continue
          }
          
          const category = parts[0]
          const amount = parseFloat(parts[1])
          const note = parts.slice(2).join(' ')
          
          if (isNaN(amount) || amount <= 0) {
            errors.push(`ç¬¬${i + 1}è¡Œï¼šé‡‘é¢æ— æ•ˆ`)
            continue
          }
          
          // æ™ºèƒ½åˆ†ç±»
          const { code } = smartCategorize(category, st.payload.group)
          
          // éªŒè¯è¿”å›çš„codeæ˜¯å¦æœ‰æ•ˆ (è¿™ä¸ªæ£€æŸ¥å®é™…ä¸Šæ˜¯å¤šä½™çš„ï¼Œå› ä¸ºsmartCategorizeæ€»æ˜¯è¿”å›æœ‰æ•ˆcode)
          const validCodes = GROUP_CATEGORIES[st.payload.group]?.map(([c]) => c) || []
          if (!validCodes.includes(code)) {
            console.warn(`æ‰¹é‡è®°å½•ï¼šåˆ†ç±»"${category}"æ— æ³•è¯†åˆ«ï¼Œä½¿ç”¨é»˜è®¤åˆ†ç±»: ${code}`)
            // ä¸å†æŠ¥é”™ï¼Œå› ä¸ºsmartCategorizeå·²ç»å¤„ç†äº†fallback
          }
          
          records.push({
            category,
            amount,
            note,
            code,
            originalLine: line
          })
        }
        
        if (errors.length > 0) {
          const errorMessage = `âŒ è¾“å…¥æœ‰è¯¯ï¼š\n\n${errors.join('\n')}\n\nè¯·é‡æ–°è¾“å…¥æˆ–ç‚¹å‡»å–æ¶ˆ`
          const cancelButton = { inline_keyboard: [[{ text: 'âŒ å–æ¶ˆ', callback_data: 'batch:cancel' }]] }
          await sendTelegramMessage(chatId, errorMessage, { reply_markup: cancelButton })
          return res.status(200).json({ ok: true })
        }
        
        if (records.length === 0) {
          const errorMessage = 'âŒ æ²¡æœ‰æœ‰æ•ˆçš„è®°å½•ï¼Œè¯·é‡æ–°è¾“å…¥æˆ–ç‚¹å‡»å–æ¶ˆ'
          const cancelButton = { inline_keyboard: [[{ text: 'âŒ å–æ¶ˆ', callback_data: 'batch:cancel' }]] }
          await sendTelegramMessage(chatId, errorMessage, { reply_markup: cancelButton })
          return res.status(200).json({ ok: true })
        }
        
        // ä¿å­˜è§£æç»“æœå¹¶æ˜¾ç¤ºç¡®è®¤é¡µé¢
        await setState(userIdForState, 'batch', 'confirm', { 
          ...st.payload, 
          records,
          currentPage: 1,
          totalPages: Math.ceil(records.length / 5)
        })
        
        await showBatchConfirmPage(chatId, records, 1, st.payload.groupLabel)
        return res.status(200).json({ ok: true })
      }
    }

    // Inline ç¼–è¾‘ï¼šå¤„ç†è¾“å…¥
    const stEdit = await getState(userIdForState)
    if (stEdit?.flow === 'edit') {
      const { recordId } = stEdit.payload || {}
      if (!recordId) { await clearState(userIdForState); return res.status(200).json({ ok: true }) }
      if (stEdit.step === 'amount') {
        const amt = parseAmountInput(text)
        if (amt == null) { await sendTelegramMessage(chatId, messages.record.amount_invalid); return res.status(200).json({ ok: true }) }
        const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
        const base = `${url.protocol}//${url.host}`
        const resp = await fetch(`${base}/api/records/record-system`, { method: 'POST', headers: { 'content-type': 'application/json' }, body: JSON.stringify({ action: 'update', userId: userIdForState, recordId, data: { amount: amt } }) })
        if (!resp.ok) { await sendTelegramMessage(chatId, 'ç¼–è¾‘å¤±è´¥'); return res.status(200).json({ ok: true }) }
        await clearState(userIdForState)
        await sendTelegramMessage(chatId, messages.history.updated)
        return res.status(200).json({ ok: true })
      }
      if (stEdit.step === 'note') {
        const note = text.slice(0, 200)
        const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
        const base = `${url.protocol}//${url.host}`
        const resp = await fetch(`${base}/api/records/record-system`, { method: 'POST', headers: { 'content-type': 'application/json' }, body: JSON.stringify({ action: 'update', userId: userIdForState, recordId, data: { note } }) })
        if (!resp.ok) { await sendTelegramMessage(chatId, 'ç¼–è¾‘å¤±è´¥'); return res.status(200).json({ ok: true }) }
        await clearState(userIdForState)
        await sendTelegramMessage(chatId, messages.history.updated)
        return res.status(200).json({ ok: true })
      }
    }

    if (st?.flow === 'start') {
      if (st.step === 'nickname') {
        const name = (text || '').trim().slice(0, 30)
        if (!name) { await sendTelegramMessage(chatId, messages.registration.nickname.validation) ; return res.status(200).json({ ok: true }) }
        await setState(userIdForState, 'start', 'phone', { nickname: name })
        await sendTelegramMessage(chatId, messages.registration.phone.prompt)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'phone') {
        const phone = normalizePhoneE164(text)
        if (!phone) { await sendTelegramMessage(chatId, messages.registration.phone.validation) ; return res.status(200).json({ ok: true }) }
        await setState(userIdForState, 'start', 'email', { ...st.payload, phone_e164: phone })
        await sendTelegramMessage(chatId, messages.registration.email.prompt)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'email') {
        const email = validateEmail(text)
        if (!email) { await sendTelegramMessage(chatId, messages.registration.email.validation) ; return res.status(200).json({ ok: true }) }
        await setState(userIdForState, 'start', 'income', { ...st.payload, email: email })
        await sendTelegramMessage(chatId, messages.registration.income.prompt)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'income') {
        const income = parseAmountInput(text)
        if (income == null || income <= 0) {
          await sendTelegramMessage(chatId, messages.registration.income.validation)
          return res.status(200).json({ ok: true })
        }
        await setState(userIdForState, 'start', 'a_pct', { ...st.payload, income })
        await sendTelegramMessage(chatId, messages.registration.budgetA.prompt)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'a_pct') {
        const aPct = parsePercentageInput(text)
        if (aPct == null) { await sendTelegramMessage(chatId, messages.registration.budgetA.validation) ; return res.status(200).json({ ok: true }) }
        if (aPct > 100) { await sendTelegramMessage(chatId, formatTemplate(messages.registration.budgetOverflow, { total: aPct })); return res.status(200).json({ ok: true }) }
        await setState(userIdForState, 'start', 'travel', { ...st.payload, a_pct: aPct })
        await sendTelegramMessage(chatId, messages.registration.travelBudget.prompt)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'travel') {
        const travel = parseAmountInput(text)
        if (travel == null || travel < 0) { await sendTelegramMessage(chatId, messages.registration.travelBudget.validation); return res.status(200).json({ ok: true }) }
        await setState(userIdForState, 'start', 'ins_med', { ...st.payload, travel_budget_annual: travel })
        await sendTelegramMessage(chatId, messages.registration.medicalInsurance.prompt)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'ins_med') {
        const insMed = parseAmountInput(text)
        if (insMed == null || insMed < 0) { await sendTelegramMessage(chatId, messages.registration.medicalInsurance.validation); return res.status(200).json({ ok: true }) }
        await setState(userIdForState, 'start', 'ins_car', { ...st.payload, annual_medical_insurance: insMed })
        await sendTelegramMessage(chatId, messages.registration.carInsurance.prompt)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'ins_car') {
        const insCar = parseAmountInput(text)
        if (insCar == null || insCar < 0) { await sendTelegramMessage(chatId, messages.registration.carInsurance.validation); return res.status(200).json({ ok: true }) }
        await setState(userIdForState, 'start', 'prev', { ...st.payload, annual_car_insurance: insCar })
        await sendTelegramMessage(chatId, messages.registration.lastMonthSpendingPct.prompt)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'prev') {
        const prevPct = parsePercentageInput(text)
        if (prevPct == null) { await sendTelegramMessage(chatId, messages.registration.lastMonthSpendingPct.validation); return res.status(200).json({ ok: true }) }
        await setState(userIdForState, 'start', 'branch', { ...st.payload, prev_month_spend: prevPct })
        await sendTelegramMessage(chatId, messages.registration.branch.prompt, { reply_markup: branchKeyboard() })
        return res.status(200).json({ ok: true })
      }
    }
    if (st?.flow === 'settings') {
      // æ–‡æœ¬ä¾§ä»…å¤„ç†å…·ä½“è¾“å…¥æ­¥éª¤ï¼Œå…¥å£ä¸é€‰æ‹©èµ° callback
      if (st.step === 'edit_nickname') {
        const name = (text || '').trim().slice(0, 30)
        if (!name) { await sendTelegramMessage(chatId, messages.registration.nickname.validation); return res.status(200).json({ ok: true }) }
        await supabase.from('user_profile').update({ display_name: name }).eq('user_id', userIdForState)
        // ä¸ç«‹å³æ¸…é™¤çŠ¶æ€ï¼Œè€Œæ˜¯æ˜¾ç¤ºæ›´æ–°åçš„æ‘˜è¦å’Œç»§ç»­é€‰é¡¹
        await showUpdatedSettingsSummary(chatId, userIdForState)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'edit_phone') {
        const phone = normalizePhoneE164(text)
        if (!phone) { await sendTelegramMessage(chatId, messages.registration.phone.validation); return res.status(200).json({ ok: true }) }
        await supabase.from('user_profile').update({ phone_e164: phone }).eq('user_id', userIdForState)
        await showUpdatedSettingsSummary(chatId, userIdForState)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'edit_email') {
        const email = validateEmail(text)
        if (!email) { await sendTelegramMessage(chatId, messages.registration.email.validation); return res.status(200).json({ ok: true }) }
        console.log(`[edit_email] å°è¯•æ›´æ–°ç”¨æˆ· ${userIdForState} çš„emailä¸º: ${email}`)
        
        // å…ˆæ£€æŸ¥ç”¨æˆ·è®°å½•æ˜¯å¦å­˜åœ¨
        const { data: existingProfile, error: checkError } = await supabase
          .from('user_profile')
          .select('user_id,email')
          .eq('user_id', userIdForState)
          .maybeSingle()
        
        console.log(`[edit_email] ç”¨æˆ·è®°å½•æ£€æŸ¥: existing=${JSON.stringify(existingProfile)}, checkError=${JSON.stringify(checkError)}`)
        
        if (checkError) {
          console.error(`[edit_email] æ£€æŸ¥ç”¨æˆ·è®°å½•å¤±è´¥:`, checkError)
          await sendTelegramMessage(chatId, 'âŒ æŸ¥è¯¢å¤±è´¥ï¼Œè¯·é‡è¯•')
          return res.status(200).json({ ok: true })
        }
        
        if (!existingProfile) {
          console.error(`[edit_email] ç”¨æˆ·è®°å½•ä¸å­˜åœ¨: userIdForState=${userIdForState}`)
          await sendTelegramMessage(chatId, 'âŒ ç”¨æˆ·è®°å½•ä¸å­˜åœ¨ï¼Œè¯·é‡æ–°æ³¨å†Œ')
          return res.status(200).json({ ok: true })
        }
        
        const { data, error, count } = await supabase.from('user_profile').update({ email: email }).eq('user_id', userIdForState).select('user_id,email')
        console.log(`[edit_email] æ•°æ®åº“æ“ä½œç»“æœ: data=${JSON.stringify(data)}, error=${JSON.stringify(error)}, count=${count}`)
        if (error) {
          console.error(`[edit_email] æ›´æ–°å¤±è´¥:`, error)
          await sendTelegramMessage(chatId, 'âŒ ä¿å­˜å¤±è´¥ï¼Œè¯·é‡è¯•')
          return res.status(200).json({ ok: true })
        }
        console.log(`[edit_email] æ›´æ–°æˆåŠŸ:`, data)
        await sendTelegramMessage(chatId, 'âœ… é‚®ç®±å·²æ›´æ–°')
        await showUpdatedSettingsSummary(chatId, userIdForState)
        await clearState(userIdForState)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'edit_income') {
        const income = parseAmountInput(text)
        if (income == null || income <= 0) { await sendTelegramMessage(chatId, messages.registration.income.validation); return res.status(200).json({ ok: true }) }
        await supabase.from('user_profile').update({ monthly_income: income }).eq('user_id', userIdForState)
        // å½“ä¸‹ç«‹å³è¡¥è®°å½“æœˆEPFï¼ˆå¹‚ç­‰ï¼‰
        const epfPct = 24 // å›ºå®š24%
        const epfAmount = income * epfPct / 100
        await tryPostMonthlyAlloc(userIdForState, 'C', 'epf_auto', epfAmount)
        await showUpdatedSettingsSummary(chatId, userIdForState)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'edit_a_pct') {
        const pct = parsePercentageInput(text)
        if (pct == null) { await sendTelegramMessage(chatId, messages.registration.budgetA.validation); return res.status(200).json({ ok: true }) }
        await supabase.from('user_profile').update({ a_pct: pct }).eq('user_id', userIdForState)
        await showUpdatedSettingsSummary(chatId, userIdForState)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'edit_travel') {
        const amt = parseAmountInput(text)
        if (amt == null || amt < 0) { await sendTelegramMessage(chatId, messages.registration.travelBudget.validation); return res.status(200).json({ ok: true }) }
        await supabase.from('user_profile').update({ travel_budget_annual: amt }).eq('user_id', userIdForState)
        // å½“ä¸‹ç«‹å³è¡¥è®°å½“æœˆåˆ†æ‘Šï¼ˆå¹‚ç­‰ï¼‰
        await tryPostMonthlyAlloc(userIdForState, 'B', 'travel_auto', amt/12)
        await showUpdatedSettingsSummary(chatId, userIdForState)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'edit_ins_med') {
        const amt = parseAmountInput(text)
        if (amt == null || amt < 0) { await sendTelegramMessage(chatId, 'è¯·è¾“å…¥åˆæ³•é‡‘é¢'); return res.status(200).json({ ok: true }) }
        await supabase.from('user_profile').update({ annual_medical_insurance: amt }).eq('user_id', userIdForState)
        await tryPostMonthlyAlloc(userIdForState, 'C', 'ins_med_auto', amt/12)
        await showUpdatedSettingsSummary(chatId, userIdForState)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'edit_ins_car') {
        const amt = parseAmountInput(text)
        if (amt == null || amt < 0) { await sendTelegramMessage(chatId, 'è¯·è¾“å…¥åˆæ³•é‡‘é¢'); return res.status(200).json({ ok: true }) }
        await supabase.from('user_profile').update({ annual_car_insurance: amt }).eq('user_id', userIdForState)
        await tryPostMonthlyAlloc(userIdForState, 'C', 'ins_car_auto', amt/12)
        await showUpdatedSettingsSummary(chatId, userIdForState)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'edit_branch') {
        // åˆ†è¡Œè®¾ç½®é€šè¿‡æŒ‰é’®é€‰æ‹©ï¼Œä¸éœ€è¦æ–‡æœ¬è¾“å…¥
        // å¦‚æœç”¨æˆ·å‘é€äº†æ–‡æœ¬ï¼Œæç¤ºä»–ä»¬ä½¿ç”¨æŒ‰é’®
        await sendTelegramMessage(chatId, 'è¯·ä½¿ç”¨ä¸Šé¢çš„æŒ‰é’®é€‰æ‹©åˆ†è¡Œï¼Œæˆ–å‘é€ /settings é‡æ–°å¼€å§‹')
        return res.status(200).json({ ok: true })
      }
    }

    // fallback
    await sendTelegramMessage(chatId, messages.help)
    return res.status(200).json({ ok: true })
  } catch (e) {
    console.error(e)
    return res.status(200).json({ ok: true })
  }
}

// Handle callback queries (inline keyboard)
export async function handleCallback(update, req, res) {
  try {
    const cq = update.callback_query
    if (!cq) return res.status(200).json({ ok: true })
    const chatId = cq.message.chat.id
    const from = cq.from
    const data = cq.data || ''
    // å…ˆåº”ç­”ï¼Œé¿å…æŒ‰é’®å¡è½¬åœˆ
    try { await answerCallbackQuery(cq.id) } catch {}
    const userId = await getOrCreateUserByTelegram(from, chatId)
    const st = await getState(userId)
    if (data.startsWith('hist:page:')) {
      const [, , range, pageStr] = data.split(':')
      const page = parseInt(pageStr || '1', 10) || 1
      const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
      const base = `${url.protocol}//${url.host}`
      const r = await fetch(`${base}/api/records/record-system`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ action: 'list', userId, data: { range, page, pageSize: 5 } }) })
      const payload = await r.json()
      if (!r.ok) { 
        await answerCallbackQuery(cq.id, 'âŒ æŸ¥è¯¢å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
        return res.status(200).json({ ok: true }) 
      }
      
      if (!payload.rows || payload.rows.length === 0) {
        await answerCallbackQuery(cq.id, `ğŸ“… ${range === 'month' ? 'æœ¬æœˆ' : range === 'lastmonth' ? 'ä¸Šæœˆ' : 'æœ¬å‘¨'}æš‚æ— è®°å½•`)
        return res.status(200).json({ ok: true })
      }
      
      const grpName = (g) => g === 'A' ? 'å¼€é”€' : g === 'B' ? 'å­¦ä¹ ' : 'å‚¨è“„'
      const catLabel = (g, code) => {
        // å…ˆæ£€æŸ¥æ˜¯å¦ä¸ºè‡ªåŠ¨ç”Ÿæˆçš„åˆ†ç±»ä»£ç 
        if (code === 'ins_med_auto') return 'åŒ»ç–—ä¿é™©ï¼ˆæœˆï¼‰'
        if (code === 'ins_car_auto') return 'è½¦é™©ï¼ˆæœˆï¼‰'
        if (code === 'epf_auto') return 'EPFï¼ˆæœˆï¼‰'
        if (code === 'travel_auto') return 'æ—…æ¸¸åŸºé‡‘ï¼ˆæœˆï¼‰'
        
        // ç„¶åæ£€æŸ¥å¸¸è§„åˆ†ç±»
        const arr = GROUP_CATEGORIES[g] || []
        const found = arr.find(([c]) => c === code)
        return found ? found[1] : code
      }
      const list = (payload.rows || []).map(row => {
        const note = row.note && row.note !== 'Auto-post' ? ` Â· ${row.note}` : ''
        return `${row.ymd} Â· ${grpName(row.category_group)}/${catLabel(row.category_group, row.category_code)} Â· RM ${Number(row.amount).toFixed(2)}${note}`
      }).join('\n') || messages.history.noRecords
      const prev = Math.max(1, (payload.page || 1) - 1)
      const next = Math.min(payload.pages || 1, (payload.page || 1) + 1)
      const rowsKb = (payload.rows || []).map(row => generateHistoryButtons(row, grpName, catLabel))
      const kb = { inline_keyboard: [
        ...rowsKb,
        [ { text: 'â¬…ï¸ ä¸Šä¸€é¡µ', callback_data: `hist:page:${range}:${prev}` }, { text: 'ä¸‹ä¸€é¡µ â¡ï¸', callback_data: `hist:page:${range}:${next}` } ]
      ] }
      await editMessageText(chatId, cq.message.message_id, `${messages.history.listHeader.replace('{range}', range === 'month' ? 'æœ¬æœˆ' : range === 'lastmonth' ? 'ä¸Šæœˆ' : 'æœ¬å‘¨')}\n${list}\n\n${messages.history.hint}`, { reply_markup: kb })
      await answerCallbackQuery(cq.id, `ğŸ“„ ç¬¬${page}é¡µ`)
      return res.status(200).json({ ok: true })
    }

    if (data.startsWith('hist:edit:')) {
      const recordId = data.split(':').pop()
      
      // æ£€æŸ¥æ˜¯å¦ä¸ºè‡ªåŠ¨ç”Ÿæˆçš„é¡¹ç›®
      const { data: record } = await supabase
        .from('records')
        .select('category_code')
        .eq('id', recordId)
        .eq('user_id', userId)
        .maybeSingle()
      
      if (record && isAutoGeneratedRecord(record.category_code)) {
        await answerCallbackQuery(update.callback_query.id, 'ğŸ”’ æ­¤è®°å½•ç”±ç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆï¼Œä¸å¯ç¼–è¾‘ã€‚å¦‚éœ€è°ƒæ•´ï¼Œè¯·åœ¨è®¾ç½®ä¸­ä¿®æ”¹ç›¸å…³é…ç½®ã€‚')
        return res.status(200).json({ ok: true })
      }
      
      await setState(userId, 'edit', 'choose', { recordId })
      const kb = { inline_keyboard: [
        [ { text: messages.history.editAmount, callback_data: 'edit:amount' }, { text: messages.history.editNote, callback_data: 'edit:note' } ],
        [ { text: messages.history.backList, callback_data: 'edit:back' } ]
      ] }
      await sendTelegramMessage(chatId, messages.history.editChoose, { reply_markup: kb })
      return res.status(200).json({ ok: true })
    }
    
    if (data.startsWith('hist:del:')) {
      const recordId = data.split(':').pop()
      
      // æ£€æŸ¥æ˜¯å¦ä¸ºè‡ªåŠ¨ç”Ÿæˆçš„é¡¹ç›®
      const { data: record } = await supabase
        .from('records')
        .select('category_code')
        .eq('id', recordId)
        .eq('user_id', userId)
        .maybeSingle()
      
      if (record && isAutoGeneratedRecord(record.category_code)) {
        await answerCallbackQuery(update.callback_query.id, 'ğŸ”’ æ­¤è®°å½•ç”±ç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆï¼Œä¸å¯åˆ é™¤ã€‚å¦‚éœ€è°ƒæ•´ï¼Œè¯·åœ¨è®¾ç½®ä¸­ä¿®æ”¹ç›¸å…³é…ç½®ã€‚')
        return res.status(200).json({ ok: true })
      }
      
      const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
      const base = `${url.protocol}//${url.host}`
      const resp = await fetch(`${base}/api/records/record-system`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ action: 'delete', userId, recordId }) })
      if (!resp.ok) { await sendTelegramMessage(chatId, 'åˆ é™¤å¤±è´¥'); return res.status(200).json({ ok: true }) }
      await sendTelegramMessage(chatId, messages.history.deleted)
      return res.status(200).json({ ok: true })
    }
    if (data === 'edit:amount' || data === 'edit:note') {
      const st = await getState(userId)
      if (!st || st.flow !== 'edit') { await sendTelegramMessage(chatId, 'ä¼šè¯å·²è¿‡æœŸ'); return res.status(200).json({ ok: true }) }
      const nextStep = data === 'edit:amount' ? 'amount' : 'note'
      await setState(userId, 'edit', nextStep, st.payload)
      await sendTelegramMessage(chatId, nextStep === 'amount' ? messages.history.amountPrompt : messages.history.notePrompt)
      return res.status(200).json({ ok: true })
    }
    if (data === 'edit:back') {
      await clearState(userId)
      await sendTelegramMessage(chatId, 'å·²å–æ¶ˆ')
      return res.status(200).json({ ok: true })
    }
    
    // å¤„ç†å†å²è®°å½•æ—¶é—´èŒƒå›´æŒ‰é’®
    if (data === 'history:month' || data === 'history:lastmonth' || data === 'history:week') {
      const range = data.split(':')[1]
      const rangeLabel = range === 'month' ? 'æœ¬æœˆ' : range === 'lastmonth' ? 'ä¸Šæœˆ' : 'æœ¬å‘¨'
      
      // è®¡ç®—æ—¥æœŸèŒƒå›´
      const today = new Date()
      let startDate, endDate
      
      switch (range) {
        case 'month':
          startDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-01`
          endDate = today.toISOString().slice(0, 10)
          break
        case 'lastmonth':
          const lastMonth = new Date(today.getFullYear(), today.getMonth() - 1, 1)
          startDate = lastMonth.toISOString().slice(0, 10)
          endDate = new Date(today.getFullYear(), today.getMonth(), 0).toISOString().slice(0, 10)
          break
        case 'week':
          const weekStart = new Date(today)
          weekStart.setDate(today.getDate() - today.getDay())
          startDate = weekStart.toISOString().slice(0, 10)
          endDate = today.toISOString().slice(0, 10)
          break
      }
      
      // æŸ¥è¯¢æŒ‡å®šæ—¶é—´èŒƒå›´çš„è®°å½•
      const { data: records, error: recordsError } = await supabase
        .from('records')
        .select('id,ymd,category_group,category_code,amount,note,created_at')
        .eq('user_id', userId)
        .eq('is_voided', false)
        .gte('ymd', startDate)
        .lte('ymd', endDate)
        .order('ymd', { ascending: false })
        .limit(20)
      
      if (recordsError) { 
        await answerCallbackQuery(cq.id, 'âŒ æŸ¥è¯¢å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
        return res.status(200).json({ ok: true }) 
      }
      
      if (!records || records.length === 0) {
        // å½“æ²¡æœ‰è®°å½•æ—¶ï¼Œæ˜¾ç¤ºæ˜ç¡®çš„æ¶ˆæ¯å¹¶ä¿æŒæŒ‰é’®å¯ç”¨
        const kb = { inline_keyboard: [
          [
            { text: 'ğŸ“… æœ¬æœˆ', callback_data: 'history:month' },
            { text: 'ğŸ“Š ä¸Šæœˆ', callback_data: 'history:lastmonth' },
            { text: 'ğŸ—“ æœ¬å‘¨', callback_data: 'history:week' }
          ],
          [{ text: 'ğŸ”™ è¿”å›æœ€è¿‘è®°å½•', callback_data: 'history:recent' }]
        ] }
        
        await editMessageText(chatId, cq.message.message_id, `ğŸ§¾ ${rangeLabel}è®°å½•\n\nğŸ“­ è¯¥æ—¶é—´æ®µæš‚æ— ä»»ä½•è®°å½•\n\nğŸ’¡ æç¤ºï¼šæ‚¨å¯ä»¥å°è¯•æŸ¥çœ‹å…¶ä»–æ—¶é—´æ®µï¼Œæˆ–è¿”å›æœ€è¿‘è®°å½•`, { reply_markup: kb })
        await answerCallbackQuery(cq.id, `ğŸ“… ${rangeLabel}æš‚æ— è®°å½•`)
        return res.status(200).json({ ok: true })
      }
      
      const grpName = (g) => g === 'A' ? 'å¼€é”€' : g === 'B' ? 'å­¦ä¹ ' : 'å‚¨è“„'
      const catLabel = (g, code) => {
        // å…ˆæ£€æŸ¥æ˜¯å¦ä¸ºè‡ªåŠ¨ç”Ÿæˆçš„åˆ†ç±»ä»£ç 
        if (code === 'ins_med_auto') return 'åŒ»ç–—ä¿é™©ï¼ˆæœˆï¼‰'
        if (code === 'ins_car_auto') return 'è½¦é™©ï¼ˆæœˆï¼‰'
        if (code === 'epf_auto') return 'EPFï¼ˆæœˆï¼‰'
        if (code === 'travel_auto') return 'æ—…æ¸¸åŸºé‡‘ï¼ˆæœˆï¼‰'
        
        // ç„¶åæ£€æŸ¥å¸¸è§„åˆ†ç±»
        const arr = GROUP_CATEGORIES[g] || []
        const found = arr.find(([c]) => c === code)
        return found ? found[1] : code
      }
      
      const list = (records || []).map(row => {
        const note = row.note && row.note !== 'Auto-post' ? ` Â· ${row.note}` : ''
        return `${row.ymd} Â· ${grpName(row.category_group)}/${catLabel(row.category_group, row.category_code)} Â· RM ${Number(row.amount).toFixed(2)}${note}`
      }).join('\n') || messages.history.noRecords
      
      const rowsKb = records.map(row => generateHistoryButtons(row, grpName, catLabel))
      const kb = { inline_keyboard: [
        ...rowsKb,
        [
        ],
        [{ text: 'ğŸ”™ è¿”å›æœ€è¿‘è®°å½•', callback_data: 'history:recent' }]
      ] }
      
      await editMessageText(chatId, cq.message.message_id, `ğŸ§¾ ${rangeLabel}è®°å½•\n${list}\n\n${messages.history.hint}`, { reply_markup: kb })
      await answerCallbackQuery(cq.id, `ğŸ“… å·²æ˜¾ç¤º${rangeLabel}è®°å½•`)
      return res.status(200).json({ ok: true })
    }
    
    if (data === 'history:recent') {
      // è¿”å›æ˜¾ç¤ºæœ€è¿‘è®°å½•
      const { data: records, error: recordsError } = await supabase
        .from('records')
        .select('id,ymd,category_group,category_code,amount,note,created_at')
        .eq('user_id', userId)
        .eq('is_voided', false)
        .order('ymd', { ascending: false })
        .limit(10)
      
      if (recordsError) { 
        await answerCallbackQuery(cq.id, 'âŒ æŸ¥è¯¢å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
        return res.status(200).json({ ok: true }) 
      }
      
      const grpName = (g) => g === 'A' ? 'å¼€é”€' : g === 'B' ? 'å­¦ä¹ ' : 'å‚¨è“„'
      const catLabel = (g, code) => {
        // å…ˆæ£€æŸ¥æ˜¯å¦ä¸ºè‡ªåŠ¨ç”Ÿæˆçš„åˆ†ç±»ä»£ç 
        if (code === 'ins_med_auto') return 'åŒ»ç–—ä¿é™©ï¼ˆæœˆï¼‰'
        if (code === 'ins_car_auto') return 'è½¦é™©ï¼ˆæœˆï¼‰'
        if (code === 'epf_auto') return 'EPFï¼ˆæœˆï¼‰'
        if (code === 'travel_auto') return 'æ—…æ¸¸åŸºé‡‘ï¼ˆæœˆï¼‰'
        
        // ç„¶åæ£€æŸ¥å¸¸è§„åˆ†ç±»
        const arr = GROUP_CATEGORIES[g] || []
        const found = arr.find(([c]) => c === code)
        return found ? found[1] : code
      }
      
      const list = (records || []).map(row => {
        const note = row.note && row.note !== 'Auto-post' ? ` Â· ${row.note}` : ''
        return `${row.ymd} Â· ${grpName(row.category_group)}/${catLabel(row.category_group, row.category_code)} Â· RM ${Number(row.amount).toFixed(2)}${note}`
      }).join('\n') || messages.history.noRecords
      
      const rowsKb = (records || []).map(row => generateHistoryButtons(row, grpName, catLabel))
      
      // æ£€æŸ¥æ˜¯å¦æœ‰æ›´å¤šè®°å½•
      const { count: totalCount } = await supabase
        .from('records')
        .select('*', { count: 'exact', head: true })
        .eq('user_id', userId)
        .eq('is_voided', false)
      
      const hasMore = totalCount > 10
      const kb = { inline_keyboard: [
        ...rowsKb,
        ...(hasMore ? [[{ text: 'ğŸ“„ æŸ¥çœ‹æ›´å¤šè®°å½•', callback_data: 'history:more' }]] : [])
      ] }
      
      await editMessageText(chatId, cq.message.message_id, `ğŸ§¾ æœ€è¿‘è®°å½•\n${list}\n\n${messages.history.hint}`, { reply_markup: kb })
      await answerCallbackQuery(cq.id, 'ğŸ”„ å·²è¿”å›æœ€è¿‘è®°å½•')
      return res.status(200).json({ ok: true })
    }
    
    if (data === 'history:more') {
      // æ˜¾ç¤ºæ›´å¤šè®°å½•ï¼ˆåˆ†é¡µï¼‰
      const { data: records, error: recordsError } = await supabase
        .from('records')
        .select('id,ymd,category_group,category_code,amount,note,created_at')
        .eq('user_id', userId)
        .eq('is_voided', false)
        .order('ymd', { ascending: false })
        .range(10, 29) // æ˜¾ç¤ºç¬¬11-30æ¡è®°å½•
      
      if (recordsError) { 
        await answerCallbackQuery(cq.id, 'âŒ æŸ¥è¯¢å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
        return res.status(200).json({ ok: true }) 
      }
      
      if (!records || records.length === 0) {
        await answerCallbackQuery(cq.id, 'ğŸ“„ æ²¡æœ‰æ›´å¤šè®°å½•äº†')
        return res.status(200).json({ ok: true })
      }
      
      const grpName = (g) => g === 'A' ? 'å¼€é”€' : g === 'B' ? 'å­¦ä¹ ' : 'å‚¨è“„'
      const catLabel = (g, code) => {
        // å…ˆæ£€æŸ¥æ˜¯å¦ä¸ºè‡ªåŠ¨ç”Ÿæˆçš„åˆ†ç±»ä»£ç 
        if (code === 'ins_med_auto') return 'åŒ»ç–—ä¿é™©ï¼ˆæœˆï¼‰'
        if (code === 'ins_car_auto') return 'è½¦é™©ï¼ˆæœˆï¼‰'
        if (code === 'epf_auto') return 'EPFï¼ˆæœˆï¼‰'
        if (code === 'travel_auto') return 'æ—…æ¸¸åŸºé‡‘ï¼ˆæœˆï¼‰'
        
        // ç„¶åæ£€æŸ¥å¸¸è§„åˆ†ç±»
        const arr = GROUP_CATEGORIES[g] || []
        const found = arr.find(([c]) => c === code)
        return found ? found[1] : code
      }
      
      const list = records.map(row => {
        const note = row.note && row.note !== 'Auto-post' ? ` Â· ${row.note}` : ''
        return `${row.ymd} Â· ${grpName(row.category_group)}/${catLabel(row.category_group, row.category_code)} Â· RM ${Number(row.amount).toFixed(2)}${note}`
      }).join('\n')
      
      const rowsKb = records.map(row => generateHistoryButtons(row, grpName, catLabel))
      
      // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰æ›´å¤šè®°å½•
      const { count: totalCount } = await supabase
        .from('records')
        .select('*', { count: 'exact', head: true })
        .eq('user_id', userId)
        .eq('is_voided', false)
      
      const hasMore = totalCount > 30
      const kb = { inline_keyboard: [
        ...rowsKb,
        ...(hasMore ? [[{ text: 'ğŸ“„ ç»§ç»­æŸ¥çœ‹æ›´å¤š', callback_data: 'history:more2' }]] : []),
        [{ text: 'ğŸ”™ è¿”å›æœ€è¿‘è®°å½•', callback_data: 'history:recent' }],
        [
        ]
      ] }
      
      await editMessageText(chatId, cq.message.message_id, `ğŸ§¾ æ›´å¤šè®°å½•ï¼ˆç¬¬11-30æ¡ï¼‰\n${list}\n\n${messages.history.hint}`, { reply_markup: kb })
      await answerCallbackQuery(cq.id, 'ğŸ“„ å·²æ˜¾ç¤ºæ›´å¤šè®°å½•')
      return res.status(200).json({ ok: true })
    }
    
    if (data === 'history:more2') {
      // æ˜¾ç¤ºæ›´å¤šè®°å½•ï¼ˆç¬¬ä¸‰é¡µï¼‰
      const { data: records, error: recordsError } = await supabase
        .from('records')
        .select('id,ymd,category_group,category_code,amount,note,created_at')
        .eq('user_id', userId)
        .eq('is_voided', false)
        .order('ymd', { ascending: false })
        .range(30, 49) // æ˜¾ç¤ºç¬¬31-50æ¡è®°å½•
      
      if (recordsError) { 
        await answerCallbackQuery(cq.id, 'âŒ æŸ¥è¯¢å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
        return res.status(200).json({ ok: true }) 
      }
      
      if (!records || records.length === 0) {
        await answerCallbackQuery(cq.id, 'ğŸ“„ æ²¡æœ‰æ›´å¤šè®°å½•äº†')
        return res.status(200).json({ ok: true })
      }
      
      const grpName = (g) => g === 'A' ? 'å¼€é”€' : g === 'B' ? 'å­¦ä¹ ' : 'å‚¨è“„'
      const catLabel = (g, code) => {
        // å…ˆæ£€æŸ¥æ˜¯å¦ä¸ºè‡ªåŠ¨ç”Ÿæˆçš„åˆ†ç±»ä»£ç 
        if (code === 'ins_med_auto') return 'åŒ»ç–—ä¿é™©ï¼ˆæœˆï¼‰'
        if (code === 'ins_car_auto') return 'è½¦é™©ï¼ˆæœˆï¼‰'
        if (code === 'epf_auto') return 'EPFï¼ˆæœˆï¼‰'
        if (code === 'travel_auto') return 'æ—…æ¸¸åŸºé‡‘ï¼ˆæœˆï¼‰'
        
        // ç„¶åæ£€æŸ¥å¸¸è§„åˆ†ç±»
        const arr = GROUP_CATEGORIES[g] || []
        const found = arr.find(([c]) => c === code)
        return found ? found[1] : code
      }
      
      const list = records.map(row => {
        const note = row.note && row.note !== 'Auto-post' ? ` Â· ${row.note}` : ''
        return `${row.ymd} Â· ${grpName(row.category_group)}/${catLabel(row.category_group, row.category_code)} Â· RM ${Number(row.amount).toFixed(2)}${note}`
      }).join('\n')
      
      const rowsKb = records.map(row => generateHistoryButtons(row, grpName, catLabel))
      
      const kb = { inline_keyboard: [
        ...rowsKb,
        [{ text: 'ğŸ”™ è¿”å›ä¸Šä¸€é¡µ', callback_data: 'history:more' }],
        [{ text: 'ğŸ  è¿”å›æœ€è¿‘è®°å½•', callback_data: 'history:recent' }],
        [
        ]
      ] }
      
      await editMessageText(chatId, cq.message.message_id, `ğŸ§¾ æ›´å¤šè®°å½•ï¼ˆç¬¬31-50æ¡ï¼‰\n${list}\n\n${messages.history.hint}`, { reply_markup: kb })
      await answerCallbackQuery(cq.id, 'ğŸ“„ å·²æ˜¾ç¤ºæ›´å¤šè®°å½•')
      return res.status(200).json({ ok: true })
    }
    console.log('å¤„ç†å›è°ƒæ•°æ®:', data, 'userId:', userId)
    
    if (data === 'send_my') {
      // ç›´æ¥æ¨¡æ‹Ÿç”¨æˆ·å‘é€äº† /my å‘½ä»¤
      console.log('æ¨¡æ‹Ÿ/myå‘½ä»¤æ‰§è¡Œ')
      return await executeMyCommand(chatId, cq.from, req, res)
    }
    
    if (data === 'my:month') {
      console.log('è¿›å…¥my:monthå¤„ç†é€»è¾‘')
      const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
      const base = `${url.protocol}//${url.host}`
      console.log('è°ƒç”¨ç»Ÿè®¡API:', `${base}/api/user/user-system`)
      const r = await fetch(`${base}/api/user/user-system`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'get-summary', userId })
      })
      const myData = await r.json()
      console.log('ç»Ÿè®¡APIå“åº”:', { status: r.status, ok: r.ok, data: myData })
      if (!r.ok) { 
        await sendTelegramMessage(chatId, `æŸ¥è¯¢å¤±è´¥: ${r.status} - ${JSON.stringify(myData)}`)
        return res.status(200).json({ ok: true }) 
      }
      
      // ç›´æ¥ä½¿ç”¨ user-system è¿”å›çš„æ ¼å¼åŒ–æ¶ˆæ¯
      const msg = myData.msg
      
      // æ ¹æ®æ—¶é—´èŒƒå›´æ›¿æ¢æ ‡é¢˜
      let title = generateMonthTitle('month')
      
      // ä¿æŒç›¸åŒçš„æ—¶é—´æ®µé€‰æ‹©æŒ‰é’®
      const keyboard = {
        inline_keyboard: [
          [
            { text: 'ğŸ“… æœ¬æœˆ', callback_data: 'my:month' },
            { text: 'ğŸ“Š ä¸Šæœˆ', callback_data: 'my:lastmonth' },
            { text: 'ğŸ—“ æœ¬å‘¨', callback_data: 'my:week' }
          ]
        ]
      };
      
      // ä½¿ç”¨ editMessageText æ›´æ–°æ¶ˆæ¯
      await editMessageText(chatId, cq.message.message_id, msg.replace(`ğŸ“Š month æ•°æ®æ€»è§ˆ`, title), { reply_markup: keyboard })
      await answerCallbackQuery(cq.id);
      return res.status(200).json({ ok: true })
    }
    if (data === 'my:lastmonth' || data === 'my:week') {
      await sendTelegramMessage(chatId, 'æš‚æ—¶åªæ”¯æŒæœ¬æœˆæ•°æ®æŸ¥çœ‹')
      await answerCallbackQuery(cq.id)
      return res.status(200).json({ ok: true })
    }
    
    if (false && (data === 'my:lastmonth' || data === 'my:week')) {
      const range = data.split(':')[1]
      const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
      const base = `${url.protocol}//${url.host}`
      const r = await fetch(`${base}/api/user/user-system`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'get-summary', userId })
      })
      const myData = await r.json()
      if (!r.ok) { await sendTelegramMessage(chatId, 'æŸ¥è¯¢å¤±è´¥'); return res.status(200).json({ ok: true }) }
      const ra = myData.realtime?.a == null ? 'N/A' : myData.realtime.a
      const rb = myData.realtime?.b == null ? 'N/A' : myData.realtime.b
      const rc = myData.realtime?.c == null ? 'N/A' : myData.realtime.c
      const da = ra === 'N/A' ? 'N/A' : (Number(ra) - Number(myData.snapshotView.a_pct)).toFixed(0)
      const aGap = (Number(myData.snapshotView.cap_a) - Number(myData.totals.a)).toFixed(2)
      const aGapLine = Number(aGap) >= 0 ? `å‰©ä½™é¢åº¦ RM ${aGap}` : `å·²è¶…å‡º RM ${Math.abs(Number(aGap)).toFixed(2)}`
      const msg = formatTemplate(messages.my.summary, {
        range,
        a: myData.display?.a || myData.totals.a.toFixed(2),
        b: myData.display?.b || myData.totals.b.toFixed(2),
        c: myData.display?.c_residual || myData.totals.c.toFixed(2),
        ra, rb, rc,
        a_pct: myData.snapshotView.a_pct,
        da,
        a_gap_line: aGapLine,
        income: myData.snapshotView.income,
        cap_a: myData.snapshotView.cap_a,
        cap_b: myData.snapshotView.cap_b,
        cap_c: myData.snapshotView.cap_c,
        epf: myData.snapshotView.epf,
        travel: myData.snapshotView.travelMonthly,
        medical: myData.snapshotView.medicalMonthly,
        car_insurance: myData.snapshotView.carInsuranceMonthly,
        category_details: formatCategoryDetails(myData.categoryBreakdown, myData.snapshotView.income, myData.snapshotView.epf, Number(myData.balance || 0))
      })
      
      // æ ¹æ®æ—¶é—´èŒƒå›´æ›¿æ¢æ ‡é¢˜
      let title = generateMonthTitle(range)
      
      await sendTelegramMessage(chatId, msg.replace(`ğŸ“Š ${range} æ•°æ®æ€»è§ˆ`, title))
      return res.status(200).json({ ok: true })
    }
    if (st && st.flow === 'settings') {
      // settings callback entries
      if (data === 'set:nickname') { await setState(userId, 'settings', 'edit_nickname', {}); await sendTelegramMessage(chatId, messages.registration.nickname.prompt); return res.status(200).json({ ok: true }) }
      if (data === 'set:phone') { await setState(userId, 'settings', 'edit_phone', {}); await sendTelegramMessage(chatId, messages.registration.phone.prompt); return res.status(200).json({ ok: true }) }
      if (data === 'set:email') { await setState(userId, 'settings', 'edit_email', {}); await sendTelegramMessage(chatId, messages.registration.email.prompt); return res.status(200).json({ ok: true }) }
      if (data === 'set:income') { await setState(userId, 'settings', 'edit_income', {}); await sendTelegramMessage(chatId, messages.registration.income.prompt); return res.status(200).json({ ok: true }) }
      if (data === 'set:a_pct') { await setState(userId, 'settings', 'edit_a_pct', {}); await sendTelegramMessage(chatId, messages.registration.budgetA.prompt); return res.status(200).json({ ok: true }) }
      if (data === 'set:travel') { await setState(userId, 'settings', 'edit_travel', {}); await sendTelegramMessage(chatId, messages.registration.travelBudget.prompt); return res.status(200).json({ ok: true }) }
      if (data === 'set:ins_med') { await setState(userId, 'settings', 'edit_ins_med', {}); await sendTelegramMessage(chatId, 'è¯·è¾“å…¥å¹´åº¦åŒ»ç–—ä¿é™©é‡‘é¢ï¼ˆRMï¼‰ï¼Œä¾‹å¦‚ 1200'); return res.status(200).json({ ok: true }) }
      if (data === 'set:ins_car') { await setState(userId, 'settings', 'edit_ins_car', {}); await sendTelegramMessage(chatId, 'è¯·è¾“å…¥å¹´åº¦è½¦é™©é‡‘é¢ï¼ˆRMï¼‰ï¼Œä¾‹å¦‚ 2400'); return res.status(200).json({ ok: true }) }
      if (data === 'set:branch') { await sendTelegramMessage(chatId, messages.registration.branch.prompt, { reply_markup: settingsBranchKeyboard() }); await setState(userId, 'settings', 'edit_branch', {}); return res.status(200).json({ ok: true }) }
      if (data === 'set:done') { 
        await clearState(userId)
        await sendTelegramMessage(chatId, 'ğŸ‰ è®¾ç½®å®Œæˆï¼æ‰€æœ‰ä¿®æ”¹å·²ä¿å­˜ã€‚\n\nç°åœ¨ä½ å¯ä»¥ï¼š\nâ€¢ /record - è®°å½•æ”¯å‡º\nâ€¢ /my - æŸ¥çœ‹ç»Ÿè®¡æŠ¥å‘Š\nâ€¢ /settings - å†æ¬¡ä¿®æ”¹èµ„æ–™\n\nğŸ’¡ æç¤ºï¼šä¸‹æ¬¡ä¿®æ”¹è®¾ç½®æ—¶ï¼Œè®°å¾—ç‚¹å‡»"âœ… å®Œæˆè®¾ç½®å¹¶ä¿å­˜æ‰€æœ‰ä¿®æ”¹"æŒ‰é’®æ¥ä¿å­˜ä¿®æ”¹ã€‚')
        return res.status(200).json({ ok: true }) 
      }
    }
    if (data.startsWith('my:')) {
      const range = data.split(':')[1] || 'month'
      const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
      const base = `${url.protocol}//${url.host}`
      const r = await fetch(`${base}/api/user/user-system`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'get-summary', userId })
      })
      const myData = await r.json()
      if (!r.ok) { await sendTelegramMessage(chatId, 'æŸ¥è¯¢å¤±è´¥'); return res.status(200).json({ ok: true }) }
      const ra = myData.realtime?.a == null ? 'N/A' : myData.realtime.a
      const rb = myData.realtime?.b == null ? 'N/A' : myData.realtime.b
      const rc = myData.realtime?.c == null ? 'N/A' : myData.realtime.c
      const da = ra === 'N/A' ? 'N/A' : (Number(ra) - Number(myData.snapshotView.a_pct)).toFixed(0)
      const aGap = (Number(myData.snapshotView.cap_a) - Number(myData.totals.a)).toFixed(2)
      const aGapLine = Number(aGap) >= 0 ? `å‰©ä½™é¢åº¦ RM ${aGap}` : `å·²è¶…å‡º RM ${Math.abs(Number(aGap)).toFixed(2)}`
      const msg = formatTemplate(messages.my.summary, {
        range,
        a: myData.display?.a || myData.totals.a.toFixed(2),
        b: myData.display?.b || myData.totals.b.toFixed(2),
        c: myData.display?.c_residual || myData.totals.c.toFixed(2),
        ra, rb, rc,
        a_pct: myData.snapshotView.a_pct,
        da,
        a_gap_line: aGapLine,
        income: myData.snapshotView.income,
        cap_a: myData.snapshotView.cap_a,
        cap_b: myData.snapshotView.cap_b,
        cap_c: myData.snapshotView.cap_c,
        epf: myData.snapshotView.epf,
        travel: Number(myData.snapshotView.travelMonthly || 0).toFixed(2),
        medical: Number(myData.snapshotView.medicalMonthly || 0).toFixed(2),
        car_insurance: Number(myData.snapshotView.carInsuranceMonthly || 0).toFixed(2),
        category_details: formatCategoryDetails(myData.categoryBreakdown, myData.snapshotView.income, myData.snapshotView.epf, Number(myData.balance || 0))
      })
      
      // æ ¹æ®æ—¶é—´èŒƒå›´æ›¿æ¢æ ‡é¢˜
      let title = generateMonthTitle(range)
      
      // ä¿æŒç›¸åŒçš„æ—¶é—´æ®µé€‰æ‹©æŒ‰é’®
      const keyboard = {
        inline_keyboard: [
          [
            { text: 'ğŸ“… æœ¬æœˆ', callback_data: 'my:month' },
            { text: 'ğŸ“Š ä¸Šæœˆ', callback_data: 'my:lastmonth' },
            { text: 'ğŸ—“ æœ¬å‘¨', callback_data: 'my:week' }
          ]
        ]
      };
      
      // ä½¿ç”¨ editMessageText æ›´æ–°æ¶ˆæ¯
      await editMessageText(chatId, cq.message.message_id, msg.replace(`ğŸ“Š ${range} æ•°æ®æ€»è§ˆ`, title), { reply_markup: keyboard })
      await answerCallbackQuery(cq.id);
      return res.status(200).json({ ok: true })
    }
    if (data.startsWith('rec:') && (!st || st.flow !== 'record')) {
      await sendTelegramMessage(chatId, 'è¯·å‘é€ /record å¼€å§‹è®°å½•')
      return res.status(200).json({ ok: true })
    }
    if (data.startsWith('rec:grp:')) {
      const grp = data.split(':').pop()
      const groupLabel = grp === 'A' ? 'ç”Ÿæ´»å¼€é”€' : grp === 'B' ? 'å­¦ä¹ æŠ•èµ„' : 'å‚¨è“„æŠ•èµ„'
      await setState(userId, 'record', 'choose_category', { group: grp, groupLabel })
      await sendTelegramMessage(chatId, formatTemplate(messages.record.choose_category, { group: groupLabel }), { reply_markup: categoryKeyboard(grp) })
      return res.status(200).json({ ok: true })
    }
    if (data.startsWith('rec:cat:')) {
      const cat = data.split(':').pop()
      const payload = { ...(st.payload || {}), category: cat, group: (st.payload||{}).group, groupLabel: (st.payload||{}).groupLabel }
      await setState(userId, 'record', 'amount', payload)
      await sendTelegramMessage(chatId, messages.record.amount_prompt)
      return res.status(200).json({ ok: true })
    }
    if (data === 'rec:confirm') {
      if (st.step !== 'confirm') { await sendTelegramMessage(chatId, 'çŠ¶æ€å·²è¿‡æœŸï¼Œè¯·é‡æ–° /record'); await clearState(userId); return res.status(200).json({ ok: true }) }
      const payload = st.payload || {}
      
      console.log('[è®°å½•ä¿å­˜] å¼€å§‹ä¿å­˜è®°å½•:', {
        userId,
        payload,
        step: st.step
      })
      
      // è°ƒç”¨åç«¯ /api/record æ‰§è¡Œå…¥åº“ + èšåˆ + streak
      const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
      const base = `${url.protocol}//${url.host}`
      
      const requestData = { 
        action: 'create', 
        userId: userId, 
        data: { 
          category_group: payload.group, 
          category_code: payload.category, 
          amount: payload.amount, 
          note: payload.note || '', 
          ymd: new Date().toISOString().slice(0,10) 
        } 
      }
      
      console.log('[è®°å½•ä¿å­˜] è¯·æ±‚æ•°æ®:', {
        url: `${base}/api/records/record-system`,
        requestData
      })
      
      const resp = await fetch(`${base}/api/records/record-system`, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(requestData)
      })
      
      if (!resp.ok) { 
        const errorData = await resp.text().catch(() => 'æ— æ³•è·å–é”™è¯¯ä¿¡æ¯')
        console.error('[è®°å½•ä¿å­˜] APIè°ƒç”¨å¤±è´¥:', {
          status: resp.status,
          statusText: resp.statusText,
          errorData,
          requestData
        })
        await sendTelegramMessage(chatId, `âŒ ä¿å­˜å¤±è´¥ï¼Œè¯·é‡è¯•\né”™è¯¯è¯¦æƒ…ï¼š${resp.status} ${resp.statusText}`)
        return res.status(200).json({ ok: true }) 
      }
      await clearState(userId)
      await sendTelegramMessage(chatId,
        formatTemplate(messages.record.saved, { groupLabel: payload.groupLabel || payload.group, amount: Number(payload.amount).toFixed(2) }),
        { reply_markup: { inline_keyboard: [[{ text: messages.post.again, callback_data: 'rec:again' }, { text: messages.post.my, callback_data: 'send_my' }]] } }
      )
      return res.status(200).json({ ok: true })
    }
    if (data === 'rec:cancel') {
      await clearState(userId)
      await sendTelegramMessage(chatId, messages.record.canceled)
      return res.status(200).json({ ok: true })
    }
    
    if (data === 'rec:again') {
      await clearState(userId)
      await sendTelegramMessage(chatId, 'ğŸ”„ è¯·é€‰æ‹©è®°å½•ç±»åˆ«ï¼š', { reply_markup: groupKeyboard() })
      return res.status(200).json({ ok: true })
    }

    // æ‰¹é‡è®°å½•å›è°ƒå¤„ç†
    if (data.startsWith('batch:page:')) {
      const page = parseInt(data.split(':')[2])
      const st = await getState(userId)
      if (!st || st.flow !== 'batch' || st.step !== 'confirm') {
        await answerCallbackQuery(cq.id, 'çŠ¶æ€å·²è¿‡æœŸï¼Œè¯·é‡æ–°å¼€å§‹æ‰¹é‡è®°å½•')
        return res.status(200).json({ ok: true })
      }
      
      await setState(userId, 'batch', 'confirm', { ...st.payload, currentPage: page })
      await showBatchConfirmPage(chatId, st.payload.records, page, st.payload.groupLabel)
      await answerCallbackQuery(cq.id, `ğŸ“„ ç¬¬${page}é¡µ`)
      return res.status(200).json({ ok: true })
    }
    
    if (data === 'batch:edit') {
      const st = await getState(userId)
      if (!st || st.flow !== 'batch' || st.step !== 'confirm') {
        await answerCallbackQuery(cq.id, 'çŠ¶æ€å·²è¿‡æœŸï¼Œè¯·é‡æ–°å¼€å§‹æ‰¹é‡è®°å½•')
        return res.status(200).json({ ok: true })
      }
      
      await answerCallbackQuery(cq.id, 'âœï¸ ä¿®æ”¹åŠŸèƒ½å¼€å‘ä¸­ï¼Œè¯·é‡æ–°è¾“å…¥æˆ–ç›´æ¥ç¡®è®¤')
      return res.status(200).json({ ok: true })
    }
    
    if (data === 'batch:delete') {
      const st = await getState(userId)
      if (!st || st.flow !== 'batch' || st.step !== 'confirm') {
        await answerCallbackQuery(cq.id, 'çŠ¶æ€å·²è¿‡æœŸï¼Œè¯·é‡æ–°å¼€å§‹æ‰¹é‡è®°å½•')
        return res.status(200).json({ ok: true })
      }
      
      await answerCallbackQuery(cq.id, 'ğŸ—‘ï¸ åˆ é™¤åŠŸèƒ½å¼€å‘ä¸­ï¼Œè¯·é‡æ–°è¾“å…¥æˆ–ç›´æ¥ç¡®è®¤')
      return res.status(200).json({ ok: true })
    }
    
    if (data === 'batch:confirm') {
      const st = await getState(userId)
      if (!st || st.flow !== 'batch' || st.step !== 'confirm') {
        await answerCallbackQuery(cq.id, 'çŠ¶æ€å·²è¿‡æœŸï¼Œè¯·é‡æ–°å¼€å§‹æ‰¹é‡è®°å½•')
        return res.status(200).json({ ok: true })
      }
      
      const { records, group } = st.payload
      
      try {
        // æ‰¹é‡æ’å…¥è®°å½•
        const recordsToInsert = records.map(record => ({
          user_id: userId,
          category_group: group,
          category_code: record.code,
          amount: record.amount,
          note: record.note || '',
          ymd: new Date().toISOString().slice(0, 10)
        }))
        
        console.log('[æ‰¹é‡è®°å½•] å‡†å¤‡æ’å…¥æ•°æ®:', {
          userId,
          group,
          recordCount: recordsToInsert.length,
          recordsToInsert
        })
        
        const { error } = await supabase.from('records').insert(recordsToInsert)
        
        if (error) {
          console.error('[æ‰¹é‡è®°å½•] æ•°æ®åº“æ’å…¥å¤±è´¥:', {
            error,
            recordsToInsert
          })
          throw error
        }

        // å¼‚æ­¥æ›´æ–°æ‰€æœ‰ç›¸å…³æ—¥æœŸçš„daily summary
        const uniqueDates = [...new Set(recordsToInsert.map(r => r.ymd))]
        const uniqueUsers = [...new Set(recordsToInsert.map(r => r.user_id))]
        for (const userId of uniqueUsers) {
          for (const ymd of uniqueDates) {
            triggerDailySummaryUpdate(userId, ymd)
          }
        }
        
        // æˆåŠŸæç¤º
        const totalAmount = records.reduce((sum, r) => sum + r.amount, 0)
        await sendTelegramMessage(chatId, 
          `âœ… æ‰¹é‡è®°å½•æˆåŠŸï¼\n\nğŸ’° æ€»è®¡ï¼šRM ${totalAmount.toFixed(2)}\nğŸ“Š è®°å½•æ•°ï¼š${records.length}ç¬”\n\nğŸ”„ ç»§ç»­è®°å½•ï¼š/record\nğŸ“Š æŸ¥çœ‹ç»Ÿè®¡ï¼š/my`, 
          { reply_markup: { inline_keyboard: [[{ text: 'ğŸ”„ ç»§ç»­è®°å½•', callback_data: 'rec:again' }, { text: 'ğŸ“Š æŸ¥çœ‹ç»Ÿè®¡', callback_data: 'send_my' }]] } }
        )
        
        await clearState(userId)
        return res.status(200).json({ ok: true })
        
      } catch (error) {
        console.error('æ‰¹é‡è®°å½•å¤±è´¥:', error)
        await sendTelegramMessage(chatId, 'âŒ æ‰¹é‡è®°å½•å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
        await clearState(userId)
        return res.status(200).json({ ok: true })
      }
    }
    
    if (data === 'batch:cancel') {
      await clearState(userId)
      await sendTelegramMessage(chatId, 'âŒ å·²å–æ¶ˆæ‰¹é‡è®°å½•')
      return res.status(200).json({ ok: true })
    }

    // çŠ¶æ€æ¢å¤å›è°ƒå¤„ç†
    if (data === 'start:continue') {
      const st = await getState(userId)
      if (!st || st.flow !== 'start') {
        await sendTelegramMessage(chatId, 'çŠ¶æ€å·²è¿‡æœŸï¼Œè¯·é‡æ–° /start')
        await clearState(userId)
        return res.status(200).json({ ok: true })
      }
      
      // æ ¹æ®å½“å‰æ­¥éª¤æ˜¾ç¤ºç›¸åº”çš„æç¤º
      const stepDesc = getStepDescription(st.step)
      let promptMsg = ''
      let keyboard = null
      
      switch (st.step) {
        case 'nickname':
          promptMsg = messages.registration.nickname.prompt
          break
        case 'phone':
          promptMsg = messages.registration.phone.prompt
          break
        case 'income':
          promptMsg = messages.registration.income.prompt
          break
        case 'a_pct':
          promptMsg = messages.registration.budgetA.prompt
          break
        case 'travel':
          promptMsg = messages.registration.travelBudget.prompt
          break
        case 'ins_med':
          promptMsg = 'ğŸ’Š è¯·è¾“å…¥å¹´åº¦åŒ»ç–—ä¿é™©é‡‘é¢ï¼ˆRMï¼‰\nä¾‹å¦‚ï¼š1200\nğŸ’¡ å¦‚æœæ²¡æœ‰è¯·è¾“å…¥ 0'
          break
        case 'ins_car':
          promptMsg = 'ğŸš— è¯·è¾“å…¥å¹´åº¦è½¦é™©é‡‘é¢ï¼ˆRMï¼‰\nä¾‹å¦‚ï¼š1500\nğŸ’¡ å¦‚æœæ²¡æœ‰è¯·è¾“å…¥ 0'
          break
        case 'prev':
          promptMsg = messages.registration.lastMonthSpendingPct.prompt
          break
        case 'branch':
          promptMsg = 'è¯·é€‰æ‹©åˆ†è¡Œå®Œæˆæ³¨å†Œï¼š'
          keyboard = branchKeyboard()
          break
      }
      
      await sendTelegramMessage(chatId, `ğŸ”„ ç»§ç»­æ³¨å†Œ\n\nå½“å‰è¿›åº¦ï¼š${stepDesc}\n\n${promptMsg}`, { reply_markup: keyboard })
      return res.status(200).json({ ok: true })
    }

    if (data === 'start:restart') {
      await clearState(userId)
      await setState(userId, 'start', 'nickname', {})
      await sendTelegramMessage(chatId, messages.registration.nickname.prompt)
      return res.status(200).json({ ok: true })
    }

    // START flow: branch selection and finalize
    if (data.startsWith('start:branch:')) {
      const code = data.split(':').pop().toUpperCase()
      const st = await getState(userId)
      if (!st || st.flow !== 'start' || st.step !== 'branch') {
        await sendTelegramMessage(chatId, 'çŠ¶æ€å·²è¿‡æœŸï¼Œè¯·é‡æ–° /start')
        await clearState(userId)
        return res.status(200).json({ ok: true })
      }
      const payload = st.payload || {}
      // Persist
      await supabase.from('users').upsert({ id: userId, branch_code: code }, { onConflict: 'id' })
      await supabase.from('user_profile').upsert({
        user_id: userId,
        display_name: payload.nickname || 'ç”¨æˆ·', // åªä½¿ç”¨ç”¨æˆ·è¾“å…¥æˆ–é»˜è®¤å€¼ï¼Œä¸ç”¨ Telegram ä¿¡æ¯
        chat_id: chatId,
        phone_e164: payload.phone_e164 || null,
        email: payload.email || null,
        monthly_income: payload.income || 0,
        a_pct: payload.a_pct || 0,
        // b_pct: payload.b_pct || 0,  // å·²åºŸå¼ƒï¼Œä¸å†ä½¿ç”¨
        travel_budget_annual: payload.travel_budget_annual || 0,
        annual_medical_insurance: payload.annual_medical_insurance || 0,
        annual_car_insurance: payload.annual_car_insurance || 0,
        prev_month_spend: payload.prev_month_spend || 0
      })
      const yyyymm = new Date().toISOString().slice(0,7)
      await supabase.from('user_month_budget').upsert({ user_id: userId, yyyymm, income: payload.income || 0, a_pct: payload.a_pct || 0 })
      await clearState(userId)
      const cPct = Math.max(0, 100 - (payload.a_pct || 0))
      await sendTelegramMessage(chatId, formatTemplate(messages.registration.success, { budgetA: payload.a_pct||0, budgetC: cPct, branch: code }))
      return res.status(200).json({ ok: true })
    }
    
    // SETTINGS flow: branch selection (when called from settings)
    if (data.startsWith('set:branch:')) {
      const code = data.split(':').pop().toUpperCase()
      console.log(`[è®¾ç½®åˆ†è¡Œ] ç”¨æˆ· ${userId} è®¾ç½®åˆ†è¡Œä¸º: ${code}`)
      
      // å…ˆæŸ¥çœ‹å½“å‰åˆ†è¡Œ
      const { data: beforeUser } = await supabase
        .from('users')
        .select('branch_code')
        .eq('id', userId)
        .single()
      console.log(`[è®¾ç½®åˆ†è¡Œ] æ›´æ–°å‰åˆ†è¡Œ: ${beforeUser?.branch_code}`)
      
      // ç›´æ¥æ›´æ–°åˆ†è¡Œä¿¡æ¯
      const { error: updateError } = await supabase
        .from('users')
        .update({ branch_code: code })
        .eq('id', userId)
      
      if (updateError) {
        console.error('[è®¾ç½®åˆ†è¡Œ] æ›´æ–°å¤±è´¥:', updateError)
        await sendTelegramMessage(chatId, 'âŒ åˆ†è¡Œè®¾ç½®å¤±è´¥ï¼Œè¯·é‡è¯•')
        return res.status(200).json({ ok: true })
      }
      
      // ç¡®è®¤æ›´æ–°åçš„åˆ†è¡Œ
      const { data: afterUser } = await supabase
        .from('users')
        .select('branch_code')
        .eq('id', userId)
        .single()
      console.log(`[è®¾ç½®åˆ†è¡Œ] æ›´æ–°ååˆ†è¡Œ: ${afterUser?.branch_code}`)
      
      console.log(`[è®¾ç½®åˆ†è¡Œ] æ›´æ–°æˆåŠŸï¼Œåˆ†è¡Œä» ${beforeUser?.branch_code} æ”¹ä¸º ${afterUser?.branch_code}`)
      
      // æ˜¾ç¤ºæ›´æ–°åçš„è®¾ç½®æ‘˜è¦
      await showUpdatedSettingsSummary(chatId, userId)
      return res.status(200).json({ ok: true })
    }
    
    if (data.startsWith('hist:view:')) {
      const recordId = data.split(':').pop()
      await answerCallbackQuery(update.callback_query.id, 'ğŸ“‹ æŸ¥çœ‹è®°å½•è¯¦æƒ…')
      // å¯ä»¥åœ¨è¿™é‡Œæ˜¾ç¤ºè®°å½•çš„è¯¦ç»†ä¿¡æ¯ï¼Œæˆ–è€…ç›´æ¥ä¸åšä»»ä½•æ“ä½œ
      return res.status(200).json({ ok: true })
    }
    
    if (data === 'hist:locked') {
      await answerCallbackQuery(update.callback_query.id, 'ğŸ”’ æ­¤è®°å½•ç”±ç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆï¼Œä¸å¯ç¼–è¾‘ã€‚å¦‚éœ€è°ƒæ•´ï¼Œè¯·åœ¨è®¾ç½®ä¸­ä¿®æ”¹ç›¸å…³é…ç½®ã€‚')
      return res.status(200).json({ ok: true })
    }

    if (data.startsWith('history:')) {
      const range = data.split(':')[1] || 'month'
      const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
      const base = `${url.protocol}//${url.host}`
      const r = await fetch(`${base}/api/records/record-system`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ action: 'list', userId, data: { range, page: 1, pageSize: 10 } }) })
      const payload = await r.json()
      if (!r.ok) { await sendTelegramMessage(chatId, 'æŸ¥è¯¢å¤±è´¥'); return res.status(200).json({ ok: true }) }
      
      const grpName = (g) => g === 'A' ? 'å¼€é”€' : g === 'B' ? 'å­¦ä¹ ' : 'å‚¨è“„'
      const catLabel = (g, code) => {
        // å…ˆæ£€æŸ¥æ˜¯å¦ä¸ºè‡ªåŠ¨ç”Ÿæˆçš„åˆ†ç±»ä»£ç 
        if (code === 'ins_med_auto') return 'åŒ»ç–—ä¿é™©ï¼ˆæœˆï¼‰'
        if (code === 'ins_car_auto') return 'è½¦é™©ï¼ˆæœˆï¼‰'
        if (code === 'epf_auto') return 'EPFï¼ˆæœˆï¼‰'
        if (code === 'travel_auto') return 'æ—…æ¸¸åŸºé‡‘ï¼ˆæœˆï¼‰'
        
        // ç„¶åæ£€æŸ¥å¸¸è§„åˆ†ç±»
        const arr = GROUP_CATEGORIES[g] || []
        const found = arr.find(([c]) => c === code)
        return found ? found[1] : code
      }
      const list = (payload.rows || []).map(row => {
        const note = row.note && row.note !== 'Auto-post' ? ` Â· ${row.note}` : ''
        return `${row.ymd} Â· ${grpName(row.category_group)}/${catLabel(row.category_group, row.category_code)} Â· RM ${Number(row.amount).toFixed(2)}${note}`
      }).join('\n') || messages.history.noRecords
      const prev = Math.max(1, (payload.page || 1) - 1)
      const next = Math.min(payload.pages || 1, (payload.page || 1) + 1)
      const rowsKb = (payload.rows || []).map(row => generateHistoryButtons(row, grpName, catLabel))
      const kb = { inline_keyboard: [
        ...rowsKb,
        [ { text: 'â¬…ï¸ ä¸Šä¸€é¡µ', callback_data: `hist:page:${range}:${prev}` }, { text: 'ä¸‹ä¸€é¡µ â¡ï¸', callback_data: `hist:page:${range}:${next}` } ],
        [
        ]
      ] }
      
      // ä½¿ç”¨ editMessageText æ›´æ–°æ¶ˆæ¯
      await editMessageText(chatId, cq.message.message_id, `${messages.history.listHeader.replace('{range}', range)}\n${list}\n\n${messages.history.hint}`, { reply_markup: kb })
      await answerCallbackQuery(cq.id);
      return res.status(200).json({ ok: true })
    }
    if (data.startsWith('rec:batch:')) {
      const group = data.split(':').pop()
      const groupLabel = group === 'A' ? 'ç”Ÿæ´»å¼€é”€' : group === 'B' ? 'å­¦ä¹ æŠ•èµ„' : 'å‚¨è“„æŠ•èµ„'
      
      // è·å–è¯¥ç»„çš„å¯ç”¨åˆ†ç±»
      const availableCategories = GROUP_CATEGORIES[group] || []
      const categoryList = availableCategories.map(([code, label]) => `â€¢ ${label}`).join('\n')
      
      await setState(userId, 'batch', 'input', { group, groupLabel })
      await sendTelegramMessage(chatId, `ğŸ”„ ${groupLabel}æ‰¹é‡è®°å½•æ¨¡å¼\n\nè¯·æŒ‰ä»¥ä¸‹æ ¼å¼è¾“å…¥è®°å½•ï¼ˆæ¯è¡Œä¸€æ¡ï¼Œæœ€å¤š20æ¡ï¼‰ï¼š\n\næ ¼å¼ï¼šåˆ†ç±» é‡‘é¢ å¤‡æ³¨\n\nğŸ“‹ å¯ç”¨åˆ†ç±»ï¼š\n${categoryList}\n\nç¤ºä¾‹ï¼š\n${group === 'A' ? 'é¤é¥® 20 åƒé¥­\nè´­ç‰© 15 ä¹°èœ\näº¤é€š 8 å…¬äº¤' : 
  group === 'B' ? 'è¯¾ç¨‹ 500 ç¼–ç¨‹è¯¾\nä¹¦ç± 80 æŠ€æœ¯ä¹¦\nåŸ¹è®­ 200 æŠ€èƒ½åŸ¹è®­' : 
  'è‚¡ç¥¨ 1000 æŠ•èµ„\nå®šå­˜ 500 å®šæœŸå­˜æ¬¾\nä¿é™© 300 åŒ»ç–—ä¿é™©'}\n\nğŸ’¡ æç¤ºï¼š\nâ€¢ ç³»ç»Ÿä¼šè‡ªåŠ¨è¯†åˆ«åˆ†ç±»\nâ€¢ ä¸åŒ¹é…çš„åˆ†ç±»ä¼šå½’åˆ°"å…¶ä»–"\nâ€¢ å»ºè®®ä½¿ç”¨ä¸Šæ–¹åˆ—å‡ºçš„åˆ†ç±»åç§°`, { reply_markup: { inline_keyboard: [[{ text: 'âŒ å–æ¶ˆ', callback_data: 'batch:cancel' }]] } })
      return res.status(200).json({ ok: true })
    }
    if (data.startsWith('rec:cat:')) {
      const cat = data.split(':').pop()
      const payload = { ...(st.payload || {}), category: cat, group: (st.payload||{}).group, groupLabel: (st.payload||{}).groupLabel }
      await setState(userId, 'record', 'amount', payload)
      await sendTelegramMessage(chatId, messages.record.amount_prompt)
      return res.status(200).json({ ok: true })
    }

    // å¤„ç† Admin æµ‹è¯•å›è°ƒ
    if (data.startsWith('admin:')) {
      const action = data.split(':')[1]
      await executeAdminTest(chatId, action, from.id, req)
      return
    }

    return res.status(200).json({ ok: true })
  } catch (e) {
    console.error(e)
    return res.status(200).json({ ok: true })
  }
}


// æ˜¾ç¤ºæ›´æ–°åçš„è®¾ç½®æ‘˜è¦å’Œç»§ç»­ä¿®æ”¹é€‰é¡¹
async function showUpdatedSettingsSummary(chatId, userId) {
  try {
    console.log(`[showUpdatedSettingsSummary] å¼€å§‹è·å–ç”¨æˆ· ${userId} çš„æœ€æ–°èµ„æ–™`)
    // è·å–æœ€æ–°çš„ç”¨æˆ·èµ„æ–™
    const { data: prof, error: profError } = await supabase
      .from('user_profile')
      .select('display_name,phone_e164,email,monthly_income,a_pct,travel_budget_annual,annual_medical_insurance,annual_car_insurance')
      .eq('user_id', userId)
      .maybeSingle()
    
    if (profError) {
      console.error(`[showUpdatedSettingsSummary] æŸ¥è¯¢user_profileå¤±è´¥:`, profError)
      return
    }
    console.log(`[showUpdatedSettingsSummary] ç”¨æˆ·èµ„æ–™:`, {
      userId,
      display_name: prof?.display_name,
      phone_e164: prof?.phone_e164,
      email: prof?.email,
      monthly_income: prof?.monthly_income
    })
    
    const { data: urow } = await supabase
      .from('users')
      .select('branch_code')
      .eq('id', userId)
      .maybeSingle()
    
    // æ˜¾ç¤ºæ›´æ–°åçš„æ‘˜è¦
    const templateParams = {
      nickname: prof?.display_name || '-',
      phone: prof?.phone_e164 || '-',
      email: prof?.email || '-',
      income: (Number(prof?.monthly_income || 0)).toFixed(2),
      a_pct: Number(prof?.a_pct || 0).toFixed(2),
      travel: (Number(prof?.travel_budget_annual || 0)).toFixed(2),
      ins_med: (Number(prof?.annual_medical_insurance || 0)).toFixed(2),
      ins_car: (Number(prof?.annual_car_insurance || 0)).toFixed(2),
      branch: (urow?.branch_code || 'æœªè®¾ç½®')
    }
    
    const sumText = formatTemplate(messages.settings.summary, templateParams)
    
    // æä¾›ç»§ç»­ä¿®æ”¹çš„é€‰é¡¹
    const kb = { inline_keyboard: [
      [ { text: messages.settings.fields.nickname, callback_data: 'set:nickname' }, { text: messages.settings.fields.phone, callback_data: 'set:phone' } ],
      [ { text: messages.settings.fields.income, callback_data: 'set:income' }, { text: messages.settings.fields.a_pct, callback_data: 'set:a_pct' } ],
      [ { text: messages.settings.fields.travel, callback_data: 'set:travel' } ],
      [ { text: 'å¹´åº¦åŒ»ç–—ä¿é™©', callback_data: 'set:ins_med' }, { text: 'å¹´åº¦è½¦é™©', callback_data: 'set:ins_car' } ],
      [ { text: messages.settings.fields.branch, callback_data: 'set:branch' } ],
      [ { text: 'âœ… å®Œæˆè®¾ç½®å¹¶ä¿å­˜æ‰€æœ‰ä¿®æ”¹', callback_data: 'set:done' } ]
    ] }
    
    await sendTelegramMessage(chatId, `âœ… å·²æ›´æ–°ï¼\n\n${sumText}\n\n${messages.settings.choose}\n\nğŸ’¡ æç¤ºï¼šä¿®æ”¹å®Œæˆåï¼Œè¯·ç‚¹å‡»ä¸‹æ–¹"âœ… å®Œæˆè®¾ç½®å¹¶ä¿å­˜æ‰€æœ‰ä¿®æ”¹"æŒ‰é’®æ¥ç»“æŸè®¾ç½®æµç¨‹ã€‚`, { reply_markup: kb })
    
    // é‡ç½®çŠ¶æ€ä¸ºé€‰æ‹©æ¨¡å¼ï¼Œè®©ç”¨æˆ·å¯ä»¥ç»§ç»­ä¿®æ”¹
    await setState(userId, 'settings', 'choose', {})
  } catch (error) {
    console.error('Error showing updated settings summary:', error)
    // å¦‚æœå‡ºé”™ï¼Œå›é€€åˆ°åŸæ¥çš„è¡Œä¸º
    await clearState(userId)
    await sendTelegramMessage(chatId, messages.settings.updated)
  }
}

// æ˜¾ç¤ºæ‰¹é‡è®°å½•ç¡®è®¤é¡µé¢
async function showBatchConfirmPage(chatId, records, page, groupLabel) {
  const pageSize = 5
  const start = (page - 1) * pageSize
  const end = start + pageSize
  const pageRecords = records.slice(start, end)
  const totalPages = Math.ceil(records.length / pageSize)
  
  // æŒ‰åˆ†ç±»åˆ†ç»„æ˜¾ç¤º
  const groupedRecords = {}
  pageRecords.forEach(record => {
    const categoryLabel = getCategoryLabel(record.code)
    if (!groupedRecords[categoryLabel]) {
      groupedRecords[categoryLabel] = []
    }
    groupedRecords[categoryLabel].push(record)
  })
  
  let message = `âœ… æ™ºèƒ½åˆ†ç±»ç»“æœ\n\n`
  
  for (const [category, items] of Object.entries(groupedRecords)) {
    message += `${category}ï¼š\n`
    items.forEach(item => {
      message += `â€¢ ${item.category} RM ${item.amount.toFixed(2)}${item.note ? ` (${item.note})` : ''}\n`
    })
    message += `\n`
  }
  
  message += `ğŸ’° æœ¬é¡µæ€»è®¡ï¼šRM ${pageRecords.reduce((sum, r) => sum + r.amount, 0).toFixed(2)}\n`
  message += `ğŸ“Š å…¨éƒ¨æ€»è®¡ï¼šRM ${records.reduce((sum, r) => sum + r.amount, 0).toFixed(2)} (${records.length}ç¬”è®°å½•)\n`
  message += `ğŸ“„ ç¬¬${page}é¡µ / å…±${totalPages}é¡µ`
  
  const keyboard = []
  
  // åˆ†é¡µæŒ‰é’®
  if (totalPages > 1) {
    const pageRow = []
    if (page > 1) pageRow.push({ text: 'â¬…ï¸ ä¸Šä¸€é¡µ', callback_data: `batch:page:${page - 1}` })
    if (page < totalPages) pageRow.push({ text: 'ä¸‹ä¸€é¡µ â¡ï¸', callback_data: `batch:page:${page + 1}` })
    if (pageRow.length > 0) keyboard.push(pageRow)
  }
  
  // æ“ä½œæŒ‰é’®
  // ä¿®æ”¹å’Œåˆ é™¤åŠŸèƒ½æš‚æœªå®ç°ï¼Œå…ˆéšè—æŒ‰é’®é¿å…ç”¨æˆ·å›°æƒ‘
  // keyboard.push([
  //   { text: 'âœï¸ ä¿®æ”¹åˆ†ç±»', callback_data: 'batch:edit' },
  //   { text: 'ğŸ—‘ï¸ åˆ é™¤è®°å½•', callback_data: 'batch:delete' }
  // ])
  
  keyboard.push([
    { text: 'âœ… ç¡®è®¤å…¨éƒ¨', callback_data: 'batch:confirm' },
    { text: 'âŒ å–æ¶ˆ', callback_data: 'batch:cancel' }
  ])
  
  await sendTelegramMessage(chatId, message, { reply_markup: { inline_keyboard: keyboard } })
}

// è·å–åˆ†ç±»æ ‡ç­¾
function getCategoryLabel(code) {
  // ç›´æ¥ä½¿ç”¨ç°æœ‰çš„åˆ†ç±»ç³»ç»Ÿ
  for (const [group, categories] of Object.entries(GROUP_CATEGORIES)) {
    const category = categories.find(([c]) => c === code)
    if (category) {
      return category[1] // è¿”å›ä¸­æ–‡æ ‡ç­¾
    }
  }
  
  // å¦‚æœæ‰¾ä¸åˆ°ï¼Œå°è¯•ä»æ‰€æœ‰åˆ†ç±»ä¸­æŸ¥æ‰¾
  for (const categories of Object.values(GROUP_CATEGORIES)) {
    const category = categories.find(([c]) => c === code)
    if (category) {
      return category[1]
    }
  }
  
  // æœ€åçš„fallbackï¼šè¿”å›codeæœ¬èº«ï¼Œä½†ç¡®ä¿å®ƒæ˜¯æœ‰æ•ˆçš„
  console.warn(`æœªæ‰¾åˆ°åˆ†ç±»æ ‡ç­¾: ${code}`)
  return code
}

// ç”Ÿæˆæœˆä»½æ ‡é¢˜
function generateMonthTitle(range) {
  const now = new Date()
  let targetDate = new Date()
  
  if (range === 'month') {
    // æœ¬æœˆ
    targetDate = now
  } else if (range === 'lastmonth') {
    // ä¸Šæœˆ
    targetDate = new Date(now.getFullYear(), now.getMonth() - 1, 1)
  } else if (range === 'week') {
    // æœ¬å‘¨
    targetDate = now
  } else if (range === 'today') {
    // ä»Šæ—¥
    targetDate = now
  }
  
  const month = targetDate.getMonth() + 1
  const monthNames = ['', '1æœˆ', '2æœˆ', '3æœˆ', '4æœˆ', '5æœˆ', '6æœˆ', '7æœˆ', '8æœˆ', '9æœˆ', '10æœˆ', '11æœˆ', '12æœˆ']
  
  if (range === 'month') return `ğŸ“Š ${monthNames[month]}ç»Ÿè®¡`
  else if (range === 'lastmonth') return `ğŸ“Š ${monthNames[month]}ç»Ÿè®¡`
  else if (range === 'week') return `ğŸ“Š æœ¬å‘¨ç»Ÿè®¡`
  else if (range === 'today') return `ğŸ“Š ä»Šæ—¥ç»Ÿè®¡`
  else return `ğŸ“Š ${range}ç»Ÿè®¡`
}

// æ‰§è¡Œ Admin æµ‹è¯•çš„å‡½æ•°
async function executeAdminTest(chatId, action, adminId, req) {
  try {
    // å‘é€å¼€å§‹æµ‹è¯•çš„æ¶ˆæ¯
    await sendTelegramMessage(chatId, `ğŸ§ª å¼€å§‹æ‰§è¡Œ ${action} æµ‹è¯•...\n\nâ³ è¯·ç¨å€™ï¼Œæµ‹è¯•å®Œæˆåä¼šæ”¶åˆ°è¯¦ç»†æŠ¥å‘Šã€‚`)
    
    // è°ƒç”¨ Admin æµ‹è¯• API
    // ä½¿ç”¨è¯·æ±‚å¤´ä¿¡æ¯æ„å»ºæ­£ç¡®çš„API URL
    let baseUrl = 'http://localhost:3000'
    
    if (req && req.headers) {
      // ä»è¯·æ±‚å¤´è·å–å½“å‰åŸŸå
      const host = req.headers.host
      const protocol = req.headers['x-forwarded-proto'] || 'https'
      
      if (host) {
        baseUrl = `${protocol}://${host}`
      }
    }
    
    // å¦‚æœä»è¯·æ±‚å¤´æ— æ³•è·å–ï¼Œå°è¯•ç¯å¢ƒå˜é‡
    if (baseUrl === 'http://localhost:3000' && process.env.VERCEL_URL) {
      baseUrl = `https://${process.env.VERCEL_URL}`
    }
    
    console.log(`[admin-test] æ„å»ºAPI URL: ${baseUrl}`)
    console.log(`[admin-test] è¯·æ±‚å¤´ä¿¡æ¯: host=${req?.headers?.host}, protocol=${req?.headers?.['x-forwarded-proto']}`)
    
    const response = await fetch(`${baseUrl}/api/test-system`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        action: action,
        adminId: adminId
      })
    })
    
    if (!response.ok) {
      const errorData = await response.json()
      throw new Error(errorData.error || 'æµ‹è¯•æ‰§è¡Œå¤±è´¥')
    }
    
    const result = await response.json()
    
    if (result.ok) {
      await sendTelegramMessage(chatId, `âœ… æµ‹è¯•æ‰§è¡Œå®Œæˆï¼\n\nğŸ¯ æµ‹è¯•åŠ¨ä½œï¼š${action}\nğŸ“Š æ€»å‘é€ï¼š${result.results.totalSent}\nâŒ æ€»å¤±è´¥ï¼š${result.results.totalFailed}\n\nğŸ“‹ è¯¦ç»†æŠ¥å‘Šå·²å‘é€ï¼Œè¯·æŸ¥æ”¶ã€‚`)
    } else {
      throw new Error(result.error || 'æµ‹è¯•æ‰§è¡Œå¤±è´¥')
    }
    
  } catch (e) {
    console.error('[admin-test] æ‰§è¡Œæµ‹è¯•å¤±è´¥:', e)
    await sendTelegramMessage(chatId, `âŒ æµ‹è¯•æ‰§è¡Œå¤±è´¥\n\né”™è¯¯ä¿¡æ¯ï¼š${e.message}\n\nè¯·æ£€æŸ¥ç³»ç»Ÿé…ç½®æˆ–ç¨åé‡è¯•ã€‚`)
  }
}

