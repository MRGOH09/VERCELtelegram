import supabase from '../lib/supabase.js'
import { messages } from '../lib/i18n.js'
import { sendTelegramMessage, assertTelegramSecret, parsePercentageInput, parseAmountInput, normalizePhoneE164, formatTemplate, answerCallbackQuery, editMessageText } from '../lib/helpers.js'
import { getOrCreateUserByTelegram, getState, setState, clearState } from '../lib/state.js'

const GROUP_CATEGORIES = {
  A: [
    ['food', '餐饮'], ['ent', '娱乐'], ['shop', '购物'], ['transport', '交通'], ['utilities', '水电'], ['mobile', '手机'], ['household', '家用'], ['other', '其他']
  ],
  B: [
    ['books', '书籍'], ['course', '课程'], ['training', '培训'], ['cert', '认证']
  ],
  C: [
    ['stock', '股票'], ['fd', '定存'], ['insurance', '保险'], ['emerg', '紧急基金'], ['other', '其他']
  ]
}

// 检查是否为自动生成的项目
function isAutoGeneratedRecord(categoryCode) {
  return categoryCode && (
    categoryCode.includes('_auto') || 
    categoryCode === 'travel_auto' ||
    categoryCode === 'ins_med_auto' ||
    categoryCode === 'ins_car_auto'
  )
}

// 智能分类算法
function smartCategorize(input, group) {
  // 直接使用现有的分类系统
  const categories = GROUP_CATEGORIES[group] || []
  
  // 智能匹配逻辑：匹配分类标签
  for (const [code, label] of categories) {
    if (input.toLowerCase().includes(label.toLowerCase())) {
      return { group, code }
    }
  }
  
  // 如果都不匹配，归到"其他"（如果该组有"其他"分类）
  const hasOther = categories.some(([code]) => code === 'other')
  if (hasOther) {
    return { group, code: 'other' }
  }
  
  // 如果没有"其他"分类，选择第一个分类作为默认
  const defaultCategory = categories[0]
  if (defaultCategory) {
    return { group, code: defaultCategory[0] }
  }
  
  // 最后的fallback
  return { group, code: 'other' }
}

// 生成历史记录按钮
function generateHistoryButtons(row, grpName, catLabel) {
  if (isAutoGeneratedRecord(row.category_code)) {
    // 自动计算的项目只显示查看，不可编辑
    return [
      { text: `📋 ${grpName(row.category_group)}·${catLabel(row.category_group, row.category_code)} RM ${Number(row.amount).toFixed(0)}`, callback_data: `hist:view:${row.id}` },
      { text: '🔒 系统生成', callback_data: 'hist:locked' }
    ]
  } else {
    // 用户手动记录的项目可以编辑
    return [
      { text: `✏️ ${grpName(row.category_group)}·${catLabel(row.category_group, row.category_code)} RM ${Number(row.amount).toFixed(0)}`, callback_data: `hist:edit:${row.id}` },
      { text: '🗑 删除', callback_data: `hist:del:${row.id}` }
    ]
  }
}

const BRANCH_CODES = [
  'PJY','BLS','OTK','PU','UKT','TLK','M2','BP','MTK','HQ','VIVA','STL','SRD','PDMR','KK'
]

// 格式化分类明细
function formatCategoryDetails(categoryBreakdown) {
  if (!categoryBreakdown || Object.keys(categoryBreakdown).length === 0) {
    return '（暂无记录）'
  }
  
  const groupLabels = { 'A': '开销', 'B': '学习', 'C': '储蓄' }
  const categoryLabels = {
    'A': { 'food': '餐饮', 'ent': '娱乐', 'shop': '购物', 'transport': '交通', 'utilities': '水电', 'mobile': '手机', 'household': '家用', 'other': '其他' },
    'B': { 'books': '书籍', 'course': '课程', 'training': '培训', 'cert': '认证', 'travel_auto': '旅游基金（月）' },
    'C': { 'stock': '股票', 'fd': '定存', 'insurance': '保险', 'emerg': '紧急基金', 'other': '其他', 'ins_med_auto': '医疗保险（月）', 'ins_car_auto': '车险（月）', 'epf_auto': 'EPF（月）' }
  }
  
  let result = ''
  for (const [group, categories] of Object.entries(categoryBreakdown)) {
    const groupLabel = groupLabels[group] || group
    result += `\n${groupLabel}：\n`
    
    for (const [code, amount] of Object.entries(categories)) {
      const categoryLabel = categoryLabels[group]?.[code] || code
      result += `  • ${categoryLabel}: RM ${Number(amount).toFixed(2)}\n`
    }
  }
  
  return result.trim()
}

function groupKeyboard() {
  return { inline_keyboard: [[
    { text: '开销', callback_data: 'rec:grp:A' },
    { text: '学习', callback_data: 'rec:grp:B' },
    { text: '储蓄', callback_data: 'rec:grp:C' }
  ]] }
}

function categoryKeyboard(group) {
  const items = GROUP_CATEGORIES[group] || []
  const rows = []
  for (let i = 0; i < items.length; i += 2) {
    const row = []
    for (let j = i; j < Math.min(i + 2, items.length); j++) {
      const [code, label] = items[j]
      row.push({ text: label, callback_data: `rec:cat:${code}` })
    }
    rows.push(row)
  }
  
  // 添加批量记录按钮
  rows.push([{ text: '🔄 批量记录', callback_data: `rec:batch:${group}` }])
  
  return { inline_keyboard: rows }
}

function branchKeyboard() {
  const rows = []
  for (let i = 0; i < BRANCH_CODES.length; i += 3) {
    const row = []
    for (let j = i; j < Math.min(i + 3, BRANCH_CODES.length); j++) {
      const code = BRANCH_CODES[j]
      row.push({ text: code, callback_data: `start:branch:${code}` })
    }
    rows.push(row)
  }
  return { inline_keyboard: rows }
}

function settingsBranchKeyboard() {
  const rows = []
  for (let i = 0; i < BRANCH_CODES.length; i += 3) {
    const row = []
    for (let j = i; j < Math.min(i + 3, BRANCH_CODES.length); j++) {
      const code = BRANCH_CODES[j]
      row.push({ text: code, callback_data: `set:branch:${code}` })
    }
    rows.push(row)
  }
  return { inline_keyboard: rows }
}

async function tryPostMonthlyAlloc(userId, group, category, amount) {
  try {
    const today = new Date()
    const ymd = `${today.toISOString().slice(0,7)}-01`
    
    // 获取用户当月预算快照中的 epf_pct，fallback 到 profile
    const [budgetResult, profileResult] = await Promise.all([
      supabase.from('user_month_budget').select('epf_pct').eq('user_id', userId).eq('yyyymm', ymd).maybeSingle(),
      supabase.from('user_profile').select('epf_pct').eq('user_id', userId).maybeSingle()
    ])
    
    const epfPct = Number(budgetResult?.data?.epf_pct || profileResult?.data?.epf_pct || 24)
    
    // 幂等：同月同类别存在则跳过（严格检查 ymd+category_code）
    const { data: exist } = await supabase
      .from('records')
      .select('id')
      .eq('user_id', userId)
      .eq('ymd', ymd)
      .eq('category_code', category)
      .eq('is_voided', false)
      .maybeSingle()
    
    if (!exist) {
      await supabase.from('records').insert([{ 
        user_id: userId, 
        category_group: group, 
        category_code: category, 
        amount, 
        note: 'Auto-post', 
        ymd 
      }])
    }
  } catch (error) {
    console.error('tryPostMonthlyAlloc error:', error)
  }
}

export default async function handler(req, res) {
  if (req.method !== 'POST') return res.status(405).json({ error: 'Method not allowed' })
  if (!assertTelegramSecret(req.headers)) {
    console.error('Bad secret', { expected: !!process.env.TELEGRAM_WEBHOOK_SECRET, got: req.headers['x-telegram-bot-api-secret-token'] || req.headers['X-Telegram-Bot-Api-Secret-Token'] })
    return res.status(401).json({ error: messages.bad_secret })
  }

  try {
    const update = req.body
    // Route callback queries to handler
    if (update && update.callback_query) {
      return handleCallback(update, req, res)
    }
    const msg = update.message || update.edited_message || update.callback_query?.message
    if (!msg) return res.status(200).json({ ok: true })

    const chatId = msg.chat.id
    const from = msg.from
    const text = (msg.text || '').trim()

    if (text.startsWith('/start')) {
      // 已注册的判定调整：优先以昵称是否存在为准（排行榜/交互展示依赖昵称）
      const userId = await getOrCreateUserByTelegram(from, chatId)
      const { data: prof } = await supabase
        .from('user_profile')
        .select('display_name,monthly_income,a_pct,b_pct')
        .eq('user_id', userId)
        .maybeSingle()
      const isRegistered = prof && !!(prof.display_name && prof.display_name.trim())
      if (isRegistered) {
        await sendTelegramMessage(chatId, '✅ 你已完成设置。\n• /record - 记录支出\n• /my - 查看统计报告\n• /settings - 修改资料')
        return res.status(200).json({ ok: true })
      }
      await setState(userId, 'start', 'nickname', {})
      await sendTelegramMessage(chatId, messages.registration.nickname.prompt)
      return res.status(200).json({ ok: true })
    }
    if (text.startsWith('/settings')) {
      const userId = await getOrCreateUserByTelegram(from, chatId)
      await setState(userId, 'settings', 'choose', {})
  const { data: prof } = await supabase
        .from('user_profile')
        .select('display_name,phone_e164,monthly_income,a_pct,b_pct,travel_budget_annual,annual_medical_insurance,annual_car_insurance')
        .eq('user_id', userId)
        .maybeSingle()
      const { data: urow } = await supabase
        .from('users')
        .select('branch_code')
        .eq('id', userId)
        .maybeSingle()
      const sumText = formatTemplate(messages.settings.summary, {
        nickname: prof?.display_name || '-',
        phone: prof?.phone_e164 || '-',
        income: (Number(prof?.monthly_income || 0)).toFixed(2),
        a_pct: Number(prof?.a_pct || 0).toFixed(2),
        b_pct: Number(prof?.b_pct || 0).toFixed(2),
        travel: (Number(prof?.travel_budget_annual || 0)).toFixed(2),
        ins_med: (Number(prof?.annual_medical_insurance || 0)).toFixed(2),
        ins_car: (Number(prof?.annual_car_insurance || 0)).toFixed(2),
        branch: (urow?.branch_code || '-')
      })
      const kb = { inline_keyboard: [
        [ { text: messages.settings.fields.nickname, callback_data: 'set:nickname' }, { text: messages.settings.fields.phone, callback_data: 'set:phone' } ],
        [ { text: messages.settings.fields.income, callback_data: 'set:income' }, { text: messages.settings.fields.a_pct, callback_data: 'set:a_pct' } ],
        [ { text: messages.settings.fields.b_pct, callback_data: 'set:b_pct' }, { text: messages.settings.fields.travel, callback_data: 'set:travel' } ],
        [ { text: '年度医疗保险', callback_data: 'set:ins_med' }, { text: '年度车险', callback_data: 'set:ins_car' } ],
        [ { text: messages.settings.fields.branch, callback_data: 'set:branch' } ],
        [ { text: '✅ 完成设置并保存所有修改', callback_data: 'set:done' } ]
      ] }
      await sendTelegramMessage(chatId, `${sumText}\n\n${messages.settings.choose}\n\n💡 提示：修改完成后，请点击下方"✅ 完成设置并保存所有修改"按钮来结束设置流程。`, { reply_markup: kb })
      return res.status(200).json({ ok: true })
    }

    if (text.startsWith('/history')) {
      // 简化：/history 命令直接显示最近记录，不再需要参数
      const { data: u, error: uErr } = await supabase.from('users').select('id').eq('telegram_id', from.id).single()
      if (uErr) { await sendTelegramMessage(chatId, messages.my.need_start); return res.status(200).json({ ok: true }) }
      
      // 直接查询最近的记录，不依赖range参数
      const { data: records, error: recordsError } = await supabase
        .from('records')
        .select('id,ymd,category_group,category_code,amount,note,created_at')
        .eq('user_id', u.id)
        .eq('is_voided', false)
        .order('ymd', { ascending: false })
        .limit(10)
      
      if (recordsError) { await sendTelegramMessage(chatId, '查询失败'); return res.status(200).json({ ok: true }) }
      
      const grpName = (g) => g === 'A' ? '开销' : g === 'B' ? '学习' : '储蓄'
      const catLabel = (g, code) => {
        // 先检查是否为自动生成的分类代码
        if (code === 'ins_med_auto') return '医疗保险（月）'
        if (code === 'ins_car_auto') return '车险（月）'
        if (code === 'epf_auto') return 'EPF（月）'
        if (code === 'travel_auto') return '旅游基金（月）'
        
        // 然后检查常规分类
        const arr = GROUP_CATEGORIES[g] || []
        const found = arr.find(([c]) => c === code)
        return found ? found[1] : code
      }
      
      const list = (records || []).map(row => {
        const note = row.note && row.note !== 'Auto-post' ? ` · ${row.note}` : ''
        return `${row.ymd} · ${grpName(row.category_group)}/${catLabel(row.category_group, row.category_code)} · RM ${Number(row.amount).toFixed(2)}${note}`
      }).join('\n') || messages.history.noRecords
      
      const rowsKb = (records || []).map(row => generateHistoryButtons(row, grpName, catLabel))
      
      // 检查是否有更多记录
      const { count: totalCount } = await supabase
        .from('records')
        .select('*', { count: 'exact', head: true })
        .eq('user_id', u.id)
        .eq('is_voided', false)
      
      const hasMore = totalCount > 10
      const kb = { inline_keyboard: [
        ...rowsKb,
        ...(hasMore ? [[{ text: '📄 查看更多记录', callback_data: 'history:more' }]] : []),
        [
          { text: '📅 本月', callback_data: 'history:month' },
          { text: '📊 上月', callback_data: 'history:lastmonth' },
          { text: '🗓 本周', callback_data: 'history:week' }
        ]
      ] }
      await sendTelegramMessage(chatId, `🧾 最近记录\n${list}\n\n${messages.history.hint}`, { reply_markup: kb })
      return res.status(200).json({ ok: true })
    }

    if (text.startsWith('/edit')) {
      const parts = text.split(/\s+/)
      // /edit id [amount] [note...]
      const recordId = parts[1]
      if (!recordId) { await sendTelegramMessage(chatId, '用法：/edit 记录ID 金额 备注'); return res.status(200).json({ ok: true }) }
      const amount = parts[2] ? Number(parts[2]) : undefined
      const note = parts.length > 3 ? parts.slice(3).join(' ') : undefined
      const userId = await getOrCreateUserByTelegram(from, chatId)
      const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
      const base = `${url.protocol}//${url.host}`
      const resp = await fetch(`${base}/api/record`, { method: 'PATCH', headers: { 'content-type': 'application/json' }, body: JSON.stringify({ userId, recordId, amount, note }) })
      const payload = await resp.json().catch(() => ({}))
      if (!resp.ok) { await sendTelegramMessage(chatId, `编辑失败：${payload.error || ''}`); return res.status(200).json({ ok: true }) }
      await sendTelegramMessage(chatId, '✅ 已更新')
      return res.status(200).json({ ok: true })
    }

    if (text.startsWith('/delete')) {
      const recordId = (text.split(/\s+/)[1] || '')
      if (!recordId) { await sendTelegramMessage(chatId, '用法：/delete 记录ID'); return res.status(200).json({ ok: true }) }
      const userId = await getOrCreateUserByTelegram(from, chatId)
      const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
      const base = `${url.protocol}//${url.host}`
      const resp = await fetch(`${base}/api/record?userId=${userId}&recordId=${encodeURIComponent(recordId)}`, { method: 'DELETE' })
      const payload = await resp.json().catch(() => ({}))
      if (!resp.ok) { await sendTelegramMessage(chatId, `删除失败：${payload.error || ''}`); return res.status(200).json({ ok: true }) }
      await sendTelegramMessage(chatId, '✅ 已删除')
      return res.status(200).json({ ok: true })
    }
    if (text.startsWith('/record')) {
      const userId = await getOrCreateUserByTelegram(from, chatId)
      await setState(userId, 'record', 'choose_group', {})
      await sendTelegramMessage(chatId, messages.record.choose_group, { reply_markup: groupKeyboard() })
      return res.status(200).json({ ok: true })
    }

    if (text.startsWith('/my')) {
      // 简化：/my 命令直接显示本月数据，不再需要参数
      const { data: u, error: uErr } = await supabase.from('users').select('id').eq('telegram_id', from.id).single()
      if (uErr) { await sendTelegramMessage(chatId, messages.my.need_start); return res.status(200).json({ ok: true }) }
      
      const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
      const base = `${url.protocol}//${url.host}`
      const r = await fetch(`${base}/api/my?userId=${u.id}&range=month`)
      const data = await r.json()
      if (!r.ok) { await sendTelegramMessage(chatId, '查询失败'); return res.status(200).json({ ok: true }) }
      
      const a = data.progress?.a ?? 0
      const b = data.progress?.b ?? 0
      const c = data.progress?.c ?? 0
      const travelMonthly = data.snapshot?.income ? (Number(data.snapshot.income) && (0)) : 0 // placeholder not used here
      const ra = data.realtime?.a == null ? 'N/A' : data.realtime.a
      const rb = data.realtime?.b == null ? 'N/A' : data.realtime.b
      const rc = data.realtime?.c == null ? 'N/A' : data.realtime.c
      const da = ra === 'N/A' ? 'N/A' : (Number(ra) - Number(data.snapshotView.a_pct)).toFixed(0)
      const aGap = (Number(data.snapshotView.cap_a) - Number(data.totals.a)).toFixed(2)
      const aGapLine = Number(aGap) >= 0 ? `剩余额度 RM ${aGap}` : `已超出 RM ${Math.abs(Number(aGap)).toFixed(2)}`
      const msg = formatTemplate(messages.my.summary, {
        range: 'month',
        a: data.display?.a || data.totals.a.toFixed(2),
        b: data.display?.b || data.totals.b.toFixed(2),
        c: data.display?.c_residual || data.totals.c.toFixed(2),
        ra, rb, rc,
        a_pct: data.snapshotView.a_pct,
        da,
        a_gap_line: aGapLine,
        income: data.snapshotView.income,
        cap_a: data.snapshotView.cap_a,
        cap_b: data.snapshotView.cap_b,
        cap_c: data.snapshotView.cap_c,
        epf: data.snapshotView.epf,
        travel: Number(data.snapshotView.travelMonthly || 0).toFixed(2),
        medical: Number(data.snapshotView.medicalMonthly || 0).toFixed(2),
        car_insurance: Number(data.snapshotView.carInsuranceMonthly || 0).toFixed(2),
        category_details: formatCategoryDetails(data.categoryBreakdown)
      })
      
      // 添加时间段选择按钮
      const keyboard = {
        inline_keyboard: [
          [
            { text: '📅 本月', callback_data: 'my:month' },
            { text: '📊 上月', callback_data: 'my:lastmonth' },
            { text: '🗓 本周', callback_data: 'my:week' }
          ]
        ]
      };
      
      await sendTelegramMessage(chatId, msg.replace('📊 month 数据总览', '📊 本月统计'), { reply_markup: keyboard })
      return res.status(200).json({ ok: true })
    }

    if (text.startsWith('/broadcast')) {
      const admins = (process.env.ADMIN_TG_IDS || '').split(',').map(s => s.trim()).filter(Boolean)
      if (!admins.includes(String(from.id))) {
        await sendTelegramMessage(chatId, messages.admin.no_perm)
        return res.status(200).json({ ok: true })
      }
      const content = text.replace('/broadcast', '').trim()
      if (!content) { await sendTelegramMessage(chatId, messages.admin.usage); return res.status(200).json({ ok: true }) }
      const { data: profs } = await supabase.from('user_profile').select('chat_id').not('chat_id', 'is', null)
      const chatIds = (profs || []).map(p => p.chat_id)
      let sent = 0
      for (const cid of chatIds) {
        try { await sendTelegramMessage(cid, content) } catch {}
        sent += 1
        if (sent % 25 === 0) await new Promise(r => setTimeout(r, 1100))
      }
      await sendTelegramMessage(chatId, formatTemplate(messages.admin.sent, { n: sent }))
      return res.status(200).json({ ok: true })
    }

    if (text.startsWith('收入') || text.includes('A%') || text.includes('B%')) {
      // 简化输入解析：收入 X；A% Y；B% Z；旅游年额 T；上月开销 P；分行 CODE
      const kvs = {}
      const segs = text.split(/[；;\n]/)
      for (const s of segs) {
        const [k, v] = s.split(/[:：\s]+/)
        if (!k || !v) continue
        kvs[k.trim()] = v.trim()
      }
      const income = parseAmountInput(kvs['收入']) ?? 0
      const aPct = parsePercentageInput(kvs['A%']) ?? 0
      const bPct = parsePercentageInput(kvs['B%']) ?? 0
      const travel = parseAmountInput(kvs['旅游年额']) ?? 0
      const prev = parseAmountInput(kvs['上月开销']) ?? 0
      const branch = (kvs['分行'] || process.env.DEFAULT_BRANCH || 'MAIN').toUpperCase()

      const { data: u, error: uErr } = await supabase.from('users').select('id').eq('telegram_id', from.id).maybeSingle()
      if (uErr) throw uErr
      let userId = u?.id
      if (!userId) {
        const { data: newU, error: insUErr } = await supabase
          .from('users')
          .insert([{ telegram_id: from.id, name: from.first_name || from.username || 'user', branch_code: branch }])
          .select('id')
          .single()
        if (insUErr) throw insUErr
        userId = newU.id
      } else {
        await supabase.from('users').update({ branch_code: branch }).eq('id', userId)
      }
      await supabase.from('user_profile').upsert({
        user_id: userId,
        display_name: from.first_name || from.username || 'user',
        chat_id: chatId,
        monthly_income: income,
        a_pct: aPct,
        b_pct: bPct,
        travel_budget_annual: travel,
        prev_month_spend: prev
      })

      // 写当月快照
      const yyyymm = new Date().toISOString().slice(0,7)
      await supabase.from('user_month_budget').upsert({ 
        user_id: userId, 
        yyyymm, 
        income, 
        a_pct: aPct, 
        b_pct: bPct,
        epf_pct: 24 // 默认 EPF 百分比
      })
      await sendTelegramMessage(chatId, messages.start_saved)
      return res.status(200).json({ ok: true })
    }

    // If user is in state flow=record, handle steps for amount/note
    const userIdForState = await getOrCreateUserByTelegram(from, chatId)
    const st = await getState(userIdForState)
    if (st?.flow === 'record') {
      if (st.step === 'amount') {
        const amt = parseAmountInput(text)
        if (amt == null) { await sendTelegramMessage(chatId, messages.record.amount_invalid); return res.status(200).json({ ok: true }) }
        const payload = { ...st.payload, amount: amt }
        await setState(userIdForState, 'record', 'note', payload)
        await sendTelegramMessage(chatId, messages.record.note_prompt)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'note') {
        const note = text === '/skip' ? '' : text.slice(0, 200)
        const payload = { ...st.payload, note }
        await setState(userIdForState, 'record', 'confirm', payload)
        const preview = formatTemplate(messages.record.preview, { group: payload.group, category: payload.category, amount: payload.amount.toFixed(2), note: note || '—' })
        await sendTelegramMessage(chatId, preview, { reply_markup: { inline_keyboard: [[{ text: '✅ 确认', callback_data: 'rec:confirm' }, { text: '❌ 取消', callback_data: 'rec:cancel' }]] } })
        return res.status(200).json({ ok: true })
      }
    }

    // 批量记录流程处理
    if (st?.flow === 'batch') {
      if (st.step === 'input') {
        // 解析批量输入
        const lines = text.split('\n').filter(line => line.trim())
        if (lines.length === 0) {
          await sendTelegramMessage(chatId, '❌ 请输入至少一条记录')
          return res.status(200).json({ ok: true })
        }
        if (lines.length > 20) {
          await sendTelegramMessage(chatId, '❌ 单次最多支持20条记录，请分批输入')
          return res.status(200).json({ ok: true })
        }

        const records = []
        const errors = []
        
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim()
          const parts = line.split(/\s+/)
          
          if (parts.length < 2) {
            errors.push(`第${i + 1}行：格式错误，需要"分类 金额 备注"`)
            continue
          }
          
          const category = parts[0]
          const amount = parseFloat(parts[1])
          const note = parts.slice(2).join(' ')
          
          if (isNaN(amount) || amount <= 0) {
            errors.push(`第${i + 1}行：金额无效`)
            continue
          }
          
          // 智能分类
          const { code } = smartCategorize(category, st.payload.group)
          
          // 验证返回的code是否有效
          const validCodes = GROUP_CATEGORIES[st.payload.group]?.map(([c]) => c) || []
          if (!validCodes.includes(code)) {
            errors.push(`第${i + 1}行：无法识别分类"${category}"`)
            continue
          }
          
          records.push({
            category,
            amount,
            note,
            code,
            originalLine: line
          })
        }
        
        if (errors.length > 0) {
          await sendTelegramMessage(chatId, `❌ 输入有误：\n\n${errors.join('\n')}\n\n请重新输入`)
          return res.status(200).json({ ok: true })
        }
        
        if (records.length === 0) {
          await sendTelegramMessage(chatId, '❌ 没有有效的记录，请重新输入')
          return res.status(200).json({ ok: true })
        }
        
        // 保存解析结果并显示确认页面
        await setState(userIdForState, 'batch', 'confirm', { 
          ...st.payload, 
          records,
          currentPage: 1,
          totalPages: Math.ceil(records.length / 5)
        })
        
        await showBatchConfirmPage(chatId, records, 1, st.payload.groupLabel)
        return res.status(200).json({ ok: true })
      }
    }

    // Inline 编辑：处理输入
    const stEdit = await getState(userIdForState)
    if (stEdit?.flow === 'edit') {
      const { recordId } = stEdit.payload || {}
      if (!recordId) { await clearState(userIdForState); return res.status(200).json({ ok: true }) }
      if (stEdit.step === 'amount') {
        const amt = parseAmountInput(text)
        if (amt == null) { await sendTelegramMessage(chatId, messages.record.amount_invalid); return res.status(200).json({ ok: true }) }
        const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
        const base = `${url.protocol}//${url.host}`
        const resp = await fetch(`${base}/api/record`, { method: 'PATCH', headers: { 'content-type': 'application/json' }, body: JSON.stringify({ userId: userIdForState, recordId, amount: amt }) })
        if (!resp.ok) { await sendTelegramMessage(chatId, '编辑失败'); return res.status(200).json({ ok: true }) }
        await clearState(userIdForState)
        await sendTelegramMessage(chatId, messages.history.updated)
        return res.status(200).json({ ok: true })
      }
      if (stEdit.step === 'note') {
        const note = text.slice(0, 200)
        const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
        const base = `${url.protocol}//${url.host}`
        const resp = await fetch(`${base}/api/record`, { method: 'PATCH', headers: { 'content-type': 'application/json' }, body: JSON.stringify({ userId: userIdForState, recordId, note }) })
        if (!resp.ok) { await sendTelegramMessage(chatId, '编辑失败'); return res.status(200).json({ ok: true }) }
        await clearState(userIdForState)
        await sendTelegramMessage(chatId, messages.history.updated)
        return res.status(200).json({ ok: true })
      }
    }

    if (st?.flow === 'start') {
      if (st.step === 'nickname') {
        const name = (text || '').trim().slice(0, 30)
        if (!name) { await sendTelegramMessage(chatId, messages.registration.nickname.validation) ; return res.status(200).json({ ok: true }) }
        await setState(userIdForState, 'start', 'phone', { nickname: name })
        await sendTelegramMessage(chatId, messages.registration.phone.prompt)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'phone') {
        const phone = normalizePhoneE164(text)
        if (!phone) { await sendTelegramMessage(chatId, messages.registration.phone.validation) ; return res.status(200).json({ ok: true }) }
        await setState(userIdForState, 'start', 'income', { ...st.payload, phone_e164: phone })
        await sendTelegramMessage(chatId, messages.registration.income.prompt)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'income') {
        const income = parseAmountInput(text)
        if (income == null || income <= 0) {
          await sendTelegramMessage(chatId, messages.registration.income.validation)
          return res.status(200).json({ ok: true })
        }
        await setState(userIdForState, 'start', 'a_pct', { ...st.payload, income })
        await sendTelegramMessage(chatId, messages.registration.budgetA.prompt)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'a_pct') {
        const aPct = parsePercentageInput(text)
        if (aPct == null) { await sendTelegramMessage(chatId, messages.registration.budgetA.validation) ; return res.status(200).json({ ok: true }) }
        await setState(userIdForState, 'start', 'b_pct', { ...st.payload, a_pct: aPct })
        await sendTelegramMessage(chatId, messages.registration.budgetB.prompt)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'b_pct') {
        const bPct = parsePercentageInput(text)
        if (bPct == null) { await sendTelegramMessage(chatId, messages.registration.budgetB.validation); return res.status(200).json({ ok: true }) }
        const aPct = st.payload?.a_pct || 0
        if (aPct + bPct > 100) { await sendTelegramMessage(chatId, formatTemplate(messages.registration.budgetOverflow, { total: aPct + bPct })); return res.status(200).json({ ok: true }) }
        await setState(userIdForState, 'start', 'travel', { ...st.payload, b_pct: bPct })
        await sendTelegramMessage(chatId, messages.registration.travelBudget.prompt)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'travel') {
        const travel = parseAmountInput(text)
        if (travel == null || travel < 0) { await sendTelegramMessage(chatId, messages.registration.travelBudget.validation); return res.status(200).json({ ok: true }) }
        await setState(userIdForState, 'start', 'prev', { ...st.payload, travel_budget_annual: travel })
        await sendTelegramMessage(chatId, messages.registration.lastMonthSpendingPct.prompt)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'prev') {
        const prevPct = parsePercentageInput(text)
        if (prevPct == null) { await sendTelegramMessage(chatId, messages.registration.lastMonthSpendingPct.validation); return res.status(200).json({ ok: true }) }
        await setState(userIdForState, 'start', 'branch', { ...st.payload, prev_month_spend: prevPct })
        await sendTelegramMessage(chatId, messages.registration.branch.prompt, { reply_markup: branchKeyboard() })
        return res.status(200).json({ ok: true })
      }
    }
    if (st?.flow === 'settings') {
      // 文本侧仅处理具体输入步骤，入口与选择走 callback
      if (st.step === 'edit_nickname') {
        const name = (text || '').trim().slice(1, 30)
        if (!name) { await sendTelegramMessage(chatId, messages.registration.nickname.validation); return res.status(200).json({ ok: true }) }
        await supabase.from('user_profile').update({ display_name: name }).eq('user_id', userIdForState)
        // 不立即清除状态，而是显示更新后的摘要和继续选项
        await showUpdatedSettingsSummary(chatId, userIdForState)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'edit_phone') {
        const phone = normalizePhoneE164(text)
        if (!phone) { await sendTelegramMessage(chatId, messages.registration.phone.validation); return res.status(200).json({ ok: true }) }
        await supabase.from('user_profile').update({ phone_e164: phone }).eq('user_id', userIdForState)
        await showUpdatedSettingsSummary(chatId, userIdForState)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'edit_income') {
        const income = parseAmountInput(text)
        if (income == null || income <= 0) { await sendTelegramMessage(chatId, messages.registration.income.validation); return res.status(200).json({ ok: true }) }
        await supabase.from('user_profile').update({ monthly_income: income }).eq('user_id', userIdForState)
        // 当下立即补记当月EPF（幂等）
        const { data: prof } = await supabase.from('user_profile').select('epf_pct').eq('user_id', userIdForState).maybeSingle()
        const epfPct = Number(prof?.epf_pct || 24)
        const epfAmount = income * epfPct / 100
        await tryPostMonthlyAlloc(userIdForState, 'C', 'epf_auto', epfAmount)
        await showUpdatedSettingsSummary(chatId, userIdForState)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'edit_a_pct' || st.step === 'edit_b_pct') {
        const pct = parsePercentageInput(text)
        if (pct == null) { await sendTelegramMessage(chatId, messages.registration.budgetA.validation); return res.status(200).json({ ok: true }) }
        const field = st.step === 'edit_a_pct' ? { a_pct: pct } : { b_pct: pct }
        await supabase.from('user_profile').update(field).eq('user_id', userIdForState)
        await showUpdatedSettingsSummary(chatId, userIdForState)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'edit_travel') {
        const amt = parseAmountInput(text)
        if (amt == null || amt < 0) { await sendTelegramMessage(chatId, messages.registration.travelBudget.validation); return res.status(200).json({ ok: true }) }
        await supabase.from('user_profile').update({ travel_budget_annual: amt }).eq('user_id', userIdForState)
        // 当下立即补记当月分摊（幂等）
        await tryPostMonthlyAlloc(userIdForState, 'B', 'travel_auto', amt/12)
        await showUpdatedSettingsSummary(chatId, userIdForState)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'edit_ins_med') {
        const amt = parseAmountInput(text)
        if (amt == null || amt < 0) { await sendTelegramMessage(chatId, '请输入合法金额'); return res.status(200).json({ ok: true }) }
        await supabase.from('user_profile').update({ annual_medical_insurance: amt }).eq('user_id', userIdForState)
        await tryPostMonthlyAlloc(userIdForState, 'C', 'ins_med_auto', amt/12)
        await showUpdatedSettingsSummary(chatId, userIdForState)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'edit_ins_car') {
        const amt = parseAmountInput(text)
        if (amt == null || amt < 0) { await sendTelegramMessage(chatId, '请输入合法金额'); return res.status(200).json({ ok: true }) }
        await supabase.from('user_profile').update({ annual_car_insurance: amt }).eq('user_id', userIdForState)
        await tryPostMonthlyAlloc(userIdForState, 'C', 'ins_car_auto', amt/12)
        await showUpdatedSettingsSummary(chatId, userIdForState)
        return res.status(200).json({ ok: true })
      }
      if (st.step === 'edit_branch') {
        // 分行设置通过按钮选择，不需要文本输入
        // 如果用户发送了文本，提示他们使用按钮
        await sendTelegramMessage(chatId, '请使用上面的按钮选择分行，或发送 /settings 重新开始')
        return res.status(200).json({ ok: true })
      }
    }

    // fallback
    await sendTelegramMessage(chatId, messages.help)
    return res.status(200).json({ ok: true })
  } catch (e) {
    console.error(e)
    return res.status(200).json({ ok: true })
  }
}

// Handle callback queries (inline keyboard)
export async function handleCallback(update, req, res) {
  try {
    const cq = update.callback_query
    if (!cq) return res.status(200).json({ ok: true })
    const chatId = cq.message.chat.id
    const from = cq.from
    const data = cq.data || ''
    // 先应答，避免按钮卡转圈
    try { await answerCallbackQuery(cq.id) } catch {}
    const userId = await getOrCreateUserByTelegram(from, chatId)
    const st = await getState(userId)
    if (data === 'rec:again') {
      await setState(userId, 'record', 'choose_group', {})
      await sendTelegramMessage(chatId, messages.record.choose_group, { reply_markup: groupKeyboard() })
      return res.status(200).json({ ok: true })
    }
    if (data.startsWith('hist:page:')) {
      const [, , range, pageStr] = data.split(':')
      const page = parseInt(pageStr || '1', 10) || 1
      const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
      const base = `${url.protocol}//${url.host}`
      const r = await fetch(`${base}/api/record?userId=${userId}&range=${encodeURIComponent(range)}&page=${page}&pageSize=5`)
      const payload = await r.json()
      if (!r.ok) { 
        await answerCallbackQuery(cq.id, '❌ 查询失败，请稍后重试')
        return res.status(200).json({ ok: true }) 
      }
      
      if (!payload.rows || payload.rows.length === 0) {
        await answerCallbackQuery(cq.id, `📅 ${range === 'month' ? '本月' : range === 'lastmonth' ? '上月' : '本周'}暂无记录`)
        return res.status(200).json({ ok: true })
      }
      
      const grpName = (g) => g === 'A' ? '开销' : g === 'B' ? '学习' : '储蓄'
      const catLabel = (g, code) => {
        // 先检查是否为自动生成的分类代码
        if (code === 'ins_med_auto') return '医疗保险（月）'
        if (code === 'ins_car_auto') return '车险（月）'
        if (code === 'epf_auto') return 'EPF（月）'
        if (code === 'travel_auto') return '旅游基金（月）'
        
        // 然后检查常规分类
        const arr = GROUP_CATEGORIES[g] || []
        const found = arr.find(([c]) => c === code)
        return found ? found[1] : code
      }
      const list = (payload.rows || []).map(row => {
        const note = row.note && row.note !== 'Auto-post' ? ` · ${row.note}` : ''
        return `${row.ymd} · ${grpName(row.category_group)}/${catLabel(row.category_group, row.category_code)} · RM ${Number(row.amount).toFixed(2)}${note}`
      }).join('\n') || messages.history.noRecords
      const prev = Math.max(1, (payload.page || 1) - 1)
      const next = Math.min(payload.pages || 1, (payload.page || 1) + 1)
      const rowsKb = (payload.rows || []).map(row => generateHistoryButtons(row, grpName, catLabel))
      const kb = { inline_keyboard: [
        ...rowsKb,
        [ { text: '⬅️ 上一页', callback_data: `hist:page:${range}:${prev}` }, { text: '下一页 ➡️', callback_data: `hist:page:${range}:${next}` } ]
      ] }
      await editMessageText(chatId, cq.message.message_id, `${messages.history.listHeader.replace('{range}', range === 'month' ? '本月' : range === 'lastmonth' ? '上月' : '本周')}\n${list}\n\n${messages.history.hint}`, { reply_markup: kb })
      await answerCallbackQuery(cq.id, `📄 第${page}页`)
      return res.status(200).json({ ok: true })
    }

    if (data.startsWith('hist:edit:')) {
      const recordId = data.split(':').pop()
      
      // 检查是否为自动生成的项目
      const { data: record } = await supabase
        .from('records')
        .select('category_code')
        .eq('id', recordId)
        .eq('user_id', userId)
        .maybeSingle()
      
      if (record && isAutoGeneratedRecord(record.category_code)) {
        await answerCallbackQuery(update.callback_query.id, '🔒 此记录由系统自动生成，不可编辑。如需调整，请在设置中修改相关配置。')
        return res.status(200).json({ ok: true })
      }
      
      await setState(userId, 'edit', 'choose', { recordId })
      const kb = { inline_keyboard: [
        [ { text: messages.history.editAmount, callback_data: 'edit:amount' }, { text: messages.history.editNote, callback_data: 'edit:note' } ],
        [ { text: messages.history.backList, callback_data: 'edit:back' } ]
      ] }
      await sendTelegramMessage(chatId, messages.history.editChoose, { reply_markup: kb })
      return res.status(200).json({ ok: true })
    }
    
    if (data.startsWith('hist:del:')) {
      const recordId = data.split(':').pop()
      
      // 检查是否为自动生成的项目
      const { data: record } = await supabase
        .from('records')
        .select('category_code')
        .eq('id', recordId)
        .eq('user_id', userId)
        .maybeSingle()
      
      if (record && isAutoGeneratedRecord(record.category_code)) {
        await answerCallbackQuery(update.callback_query.id, '🔒 此记录由系统自动生成，不可删除。如需调整，请在设置中修改相关配置。')
        return res.status(200).json({ ok: true })
      }
      
      const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
      const base = `${url.protocol}//${url.host}`
      const resp = await fetch(`${base}/api/record?userId=${userId}&recordId=${encodeURIComponent(recordId)}`, { method: 'DELETE' })
      if (!resp.ok) { await sendTelegramMessage(chatId, '删除失败'); return res.status(200).json({ ok: true }) }
      await sendTelegramMessage(chatId, messages.history.deleted)
      return res.status(200).json({ ok: true })
    }
    if (data === 'edit:amount' || data === 'edit:note') {
      const st = await getState(userId)
      if (!st || st.flow !== 'edit') { await sendTelegramMessage(chatId, '会话已过期'); return res.status(200).json({ ok: true }) }
      const nextStep = data === 'edit:amount' ? 'amount' : 'note'
      await setState(userId, 'edit', nextStep, st.payload)
      await sendTelegramMessage(chatId, nextStep === 'amount' ? messages.history.amountPrompt : messages.history.notePrompt)
      return res.status(200).json({ ok: true })
    }
    if (data === 'edit:back') {
      await clearState(userId)
      await sendTelegramMessage(chatId, '已取消')
      return res.status(200).json({ ok: true })
    }
    
    // 处理历史记录时间范围按钮
    if (data === 'history:month' || data === 'history:lastmonth' || data === 'history:week') {
      const range = data.split(':')[1]
      const rangeLabel = range === 'month' ? '本月' : range === 'lastmonth' ? '上月' : '本周'
      
      // 计算日期范围
      const today = new Date()
      let startDate, endDate
      
      switch (range) {
        case 'month':
          startDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-01`
          endDate = today.toISOString().slice(0, 10)
          break
        case 'lastmonth':
          const lastMonth = new Date(today.getFullYear(), today.getMonth() - 1, 1)
          startDate = lastMonth.toISOString().slice(0, 10)
          endDate = new Date(today.getFullYear(), today.getMonth(), 0).toISOString().slice(0, 10)
          break
        case 'week':
          const weekStart = new Date(today)
          weekStart.setDate(today.getDate() - today.getDay())
          startDate = weekStart.toISOString().slice(0, 10)
          endDate = today.toISOString().slice(0, 10)
          break
      }
      
      // 查询指定时间范围的记录
      const { data: records, error: recordsError } = await supabase
        .from('records')
        .select('id,ymd,category_group,category_code,amount,note,created_at')
        .eq('user_id', userId)
        .eq('is_voided', false)
        .gte('ymd', startDate)
        .lte('ymd', endDate)
        .order('ymd', { ascending: false })
        .limit(20)
      
      if (recordsError) { 
        await answerCallbackQuery(cq.id, '❌ 查询失败，请稍后重试')
        return res.status(200).json({ ok: true }) 
      }
      
      if (!records || records.length === 0) {
        // 当没有记录时，显示明确的消息并保持按钮可用
        const kb = { inline_keyboard: [
          [
            { text: '📅 本月', callback_data: 'history:month' },
            { text: '📊 上月', callback_data: 'history:lastmonth' },
            { text: '🗓 本周', callback_data: 'history:week' }
          ],
          [{ text: '🔙 返回最近记录', callback_data: 'history:recent' }]
        ] }
        
        await editMessageText(chatId, cq.message.message_id, `🧾 ${rangeLabel}记录\n\n📭 该时间段暂无任何记录\n\n💡 提示：您可以尝试查看其他时间段，或返回最近记录`, { reply_markup: kb })
        await answerCallbackQuery(cq.id, `📅 ${rangeLabel}暂无记录`)
        return res.status(200).json({ ok: true })
      }
      
      const grpName = (g) => g === 'A' ? '开销' : g === 'B' ? '学习' : '储蓄'
      const catLabel = (g, code) => {
        // 先检查是否为自动生成的分类代码
        if (code === 'ins_med_auto') return '医疗保险（月）'
        if (code === 'ins_car_auto') return '车险（月）'
        if (code === 'epf_auto') return 'EPF（月）'
        if (code === 'travel_auto') return '旅游基金（月）'
        
        // 然后检查常规分类
        const arr = GROUP_CATEGORIES[g] || []
        const found = arr.find(([c]) => c === code)
        return found ? found[1] : code
      }
      
      const list = (records || []).map(row => {
        const note = row.note && row.note !== 'Auto-post' ? ` · ${row.note}` : ''
        return `${row.ymd} · ${grpName(row.category_group)}/${catLabel(row.category_group, row.category_code)} · RM ${Number(row.amount).toFixed(2)}${note}`
      }).join('\n') || messages.history.noRecords
      
      const rowsKb = records.map(row => generateHistoryButtons(row, grpName, catLabel))
      const kb = { inline_keyboard: [
        ...rowsKb,
        [
          { text: '📅 本月', callback_data: 'history:month' },
          { text: '📊 上月', callback_data: 'history:lastmonth' },
          { text: '🗓 本周', callback_data: 'history:week' }
        ],
        [{ text: '🔙 返回最近记录', callback_data: 'history:recent' }]
      ] }
      
      await editMessageText(chatId, cq.message.message_id, `🧾 ${rangeLabel}记录\n${list}\n\n${messages.history.hint}`, { reply_markup: kb })
      await answerCallbackQuery(cq.id, `📅 已显示${rangeLabel}记录`)
      return res.status(200).json({ ok: true })
    }
    
    if (data === 'history:recent') {
      // 返回显示最近记录
      const { data: records, error: recordsError } = await supabase
        .from('records')
        .select('id,ymd,category_group,category_code,amount,note,created_at')
        .eq('user_id', userId)
        .eq('is_voided', false)
        .order('ymd', { ascending: false })
        .limit(10)
      
      if (recordsError) { 
        await answerCallbackQuery(cq.id, '❌ 查询失败，请稍后重试')
        return res.status(200).json({ ok: true }) 
      }
      
      const grpName = (g) => g === 'A' ? '开销' : g === 'B' ? '学习' : '储蓄'
      const catLabel = (g, code) => {
        // 先检查是否为自动生成的分类代码
        if (code === 'ins_med_auto') return '医疗保险（月）'
        if (code === 'ins_car_auto') return '车险（月）'
        if (code === 'epf_auto') return 'EPF（月）'
        if (code === 'travel_auto') return '旅游基金（月）'
        
        // 然后检查常规分类
        const arr = GROUP_CATEGORIES[g] || []
        const found = arr.find(([c]) => c === code)
        return found ? found[1] : code
      }
      
      const list = (records || []).map(row => {
        const note = row.note && row.note !== 'Auto-post' ? ` · ${row.note}` : ''
        return `${row.ymd} · ${grpName(row.category_group)}/${catLabel(row.category_group, row.category_code)} · RM ${Number(row.amount).toFixed(2)}${note}`
      }).join('\n') || messages.history.noRecords
      
      const rowsKb = (records || []).map(row => generateHistoryButtons(row, grpName, catLabel))
      
      // 检查是否有更多记录
      const { count: totalCount } = await supabase
        .from('records')
        .select('*', { count: 'exact', head: true })
        .eq('user_id', userId)
        .eq('is_voided', false)
      
      const hasMore = totalCount > 10
      const kb = { inline_keyboard: [
        ...rowsKb,
        ...(hasMore ? [[{ text: '📄 查看更多记录', callback_data: 'history:more' }]] : []),
        [
          { text: '📅 本月', callback_data: 'history:month' },
          { text: '📊 上月', callback_data: 'history:lastmonth' },
          { text: '🗓 本周', callback_data: 'history:week' }
        ]
      ] }
      
      await editMessageText(chatId, cq.message.message_id, `🧾 最近记录\n${list}\n\n${messages.history.hint}`, { reply_markup: kb })
      await answerCallbackQuery(cq.id, '🔄 已返回最近记录')
      return res.status(200).json({ ok: true })
    }
    
    if (data === 'history:more') {
      // 显示更多记录（分页）
      const { data: records, error: recordsError } = await supabase
        .from('records')
        .select('id,ymd,category_group,category_code,amount,note,created_at')
        .eq('user_id', userId)
        .eq('is_voided', false)
        .order('ymd', { ascending: false })
        .range(10, 29) // 显示第11-30条记录
      
      if (recordsError) { 
        await answerCallbackQuery(cq.id, '❌ 查询失败，请稍后重试')
        return res.status(200).json({ ok: true }) 
      }
      
      if (!records || records.length === 0) {
        await answerCallbackQuery(cq.id, '📄 没有更多记录了')
        return res.status(200).json({ ok: true })
      }
      
      const grpName = (g) => g === 'A' ? '开销' : g === 'B' ? '学习' : '储蓄'
      const catLabel = (g, code) => {
        // 先检查是否为自动生成的分类代码
        if (code === 'ins_med_auto') return '医疗保险（月）'
        if (code === 'ins_car_auto') return '车险（月）'
        if (code === 'epf_auto') return 'EPF（月）'
        if (code === 'travel_auto') return '旅游基金（月）'
        
        // 然后检查常规分类
        const arr = GROUP_CATEGORIES[g] || []
        const found = arr.find(([c]) => c === code)
        return found ? found[1] : code
      }
      
      const list = records.map(row => {
        const note = row.note && row.note !== 'Auto-post' ? ` · ${row.note}` : ''
        return `${row.ymd} · ${grpName(row.category_group)}/${catLabel(row.category_group, row.category_code)} · RM ${Number(row.amount).toFixed(2)}${note}`
      }).join('\n')
      
      const rowsKb = records.map(row => generateHistoryButtons(row, grpName, catLabel))
      
      // 检查是否还有更多记录
      const { count: totalCount } = await supabase
        .from('records')
        .select('*', { count: 'exact', head: true })
        .eq('user_id', userId)
        .eq('is_voided', false)
      
      const hasMore = totalCount > 30
      const kb = { inline_keyboard: [
        ...rowsKb,
        ...(hasMore ? [[{ text: '📄 继续查看更多', callback_data: 'history:more2' }]] : []),
        [{ text: '🔙 返回最近记录', callback_data: 'history:recent' }],
        [
          { text: '📅 本月', callback_data: 'history:month' },
          { text: '📊 上月', callback_data: 'history:lastmonth' },
          { text: '🗓 本周', callback_data: 'history:week' }
        ]
      ] }
      
      await editMessageText(chatId, cq.message.message_id, `🧾 更多记录（第11-30条）\n${list}\n\n${messages.history.hint}`, { reply_markup: kb })
      await answerCallbackQuery(cq.id, '📄 已显示更多记录')
      return res.status(200).json({ ok: true })
    }
    
    if (data === 'history:more2') {
      // 显示更多记录（第三页）
      const { data: records, error: recordsError } = await supabase
        .from('records')
        .select('id,ymd,category_group,category_code,amount,note,created_at')
        .eq('user_id', userId)
        .eq('is_voided', false)
        .order('ymd', { ascending: false })
        .range(30, 49) // 显示第31-50条记录
      
      if (recordsError) { 
        await answerCallbackQuery(cq.id, '❌ 查询失败，请稍后重试')
        return res.status(200).json({ ok: true }) 
      }
      
      if (!records || records.length === 0) {
        await answerCallbackQuery(cq.id, '📄 没有更多记录了')
        return res.status(200).json({ ok: true })
      }
      
      const grpName = (g) => g === 'A' ? '开销' : g === 'B' ? '学习' : '储蓄'
      const catLabel = (g, code) => {
        // 先检查是否为自动生成的分类代码
        if (code === 'ins_med_auto') return '医疗保险（月）'
        if (code === 'ins_car_auto') return '车险（月）'
        if (code === 'epf_auto') return 'EPF（月）'
        if (code === 'travel_auto') return '旅游基金（月）'
        
        // 然后检查常规分类
        const arr = GROUP_CATEGORIES[g] || []
        const found = arr.find(([c]) => c === code)
        return found ? found[1] : code
      }
      
      const list = records.map(row => {
        const note = row.note && row.note !== 'Auto-post' ? ` · ${row.note}` : ''
        return `${row.ymd} · ${grpName(row.category_group)}/${catLabel(row.category_group, row.category_code)} · RM ${Number(row.amount).toFixed(2)}${note}`
      }).join('\n')
      
      const rowsKb = records.map(row => generateHistoryButtons(row, grpName, catLabel))
      
      const kb = { inline_keyboard: [
        ...rowsKb,
        [{ text: '🔙 返回上一页', callback_data: 'history:more' }],
        [{ text: '🏠 返回最近记录', callback_data: 'history:recent' }],
        [
          { text: '📅 本月', callback_data: 'history:month' },
          { text: '📊 上月', callback_data: 'history:lastmonth' },
          { text: '🗓 本周', callback_data: 'history:week' }
        ]
      ] }
      
      await editMessageText(chatId, cq.message.message_id, `🧾 更多记录（第31-50条）\n${list}\n\n${messages.history.hint}`, { reply_markup: kb })
      await answerCallbackQuery(cq.id, '📄 已显示更多记录')
      return res.status(200).json({ ok: true })
    }
    if (data === 'my:month') {
      const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
      const base = `${url.protocol}//${url.host}`
      const r = await fetch(`${base}/api/my?userId=${userId}&range=month`)
      const myData = await r.json()
      if (!r.ok) { await sendTelegramMessage(chatId, '查询失败'); return res.status(200).json({ ok: true }) }
      const ra = myData.realtime?.a == null ? 'N/A' : myData.realtime.a
      const rb = myData.realtime?.b == null ? 'N/A' : myData.realtime.b
      const rc = myData.realtime?.c == null ? 'N/A' : myData.realtime.c
      const da = ra === 'N/A' ? 'N/A' : (Number(ra) - Number(myData.snapshotView.a_pct)).toFixed(0)
      const aGap = (Number(myData.snapshotView.cap_a) - Number(myData.totals.a)).toFixed(2)
      const aGapLine = Number(aGap) >= 0 ? `剩余额度 RM ${aGap}` : `已超出 RM ${Math.abs(Number(aGap)).toFixed(2)}`
      const msg = formatTemplate(messages.my.summary, {
        range: 'month',
        a: myData.display?.a || myData.totals.a.toFixed(2),
        b: myData.display?.b || myData.totals.b.toFixed(2),
        c: myData.display?.c_residual || myData.totals.c.toFixed(2),
        ra, rb, rc,
        a_pct: myData.snapshotView.a_pct,
        da,
        a_gap_line: aGapLine,
        income: myData.snapshotView.income,
        cap_a: myData.snapshotView.cap_a,
        cap_b: myData.snapshotView.cap_b,
        cap_c: myData.snapshotView.cap_c,
        epf: myData.snapshotView.epf,
        travel: Number(myData.snapshotView.travelMonthly || 0).toFixed(2),
        medical: Number(myData.snapshotView.medicalMonthly || 0).toFixed(2),
        car_insurance: Number(myData.snapshotView.carInsuranceMonthly || 0).toFixed(2),
        category_details: formatCategoryDetails(myData.categoryBreakdown)
      })
      
      // 根据时间范围替换标题
      let title = generateMonthTitle(range)
      
      // 保持相同的时间段选择按钮
      const keyboard = {
        inline_keyboard: [
          [
            { text: '📅 本月', callback_data: 'my:month' },
            { text: '📊 上月', callback_data: 'my:lastmonth' },
            { text: '🗓 本周', callback_data: 'my:week' }
          ]
        ]
      };
      
      // 使用 editMessageText 更新消息
      await editMessageText(chatId, cq.message.message_id, msg.replace(`📊 ${range} 数据总览`, title), { reply_markup: keyboard })
      await answerCallbackQuery(cq.id);
      return res.status(200).json({ ok: true })
    }
    if (data === 'my:today' || data === 'my:lastmonth') {
      const range = data.split(':')[1]
      const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
      const base = `${url.protocol}//${url.host}`
      const r = await fetch(`${base}/api/my?userId=${userId}&range=${encodeURIComponent(range)}`)
      const myData = await r.json()
      if (!r.ok) { await sendTelegramMessage(chatId, '查询失败'); return res.status(200).json({ ok: true }) }
      const ra = myData.realtime?.a == null ? 'N/A' : myData.realtime.a
      const rb = myData.realtime?.b == null ? 'N/A' : myData.realtime.b
      const rc = myData.realtime?.c == null ? 'N/A' : myData.realtime.c
      const da = ra === 'N/A' ? 'N/A' : (Number(ra) - Number(myData.snapshotView.a_pct)).toFixed(0)
      const aGap = (Number(myData.snapshotView.cap_a) - Number(myData.totals.a)).toFixed(2)
      const aGapLine = Number(aGap) >= 0 ? `剩余额度 RM ${aGap}` : `已超出 RM ${Math.abs(Number(aGap)).toFixed(2)}`
      const msg = formatTemplate(messages.my.summary, {
        range,
        a: myData.display?.a || myData.totals.a.toFixed(2),
        b: myData.display?.b || myData.totals.b.toFixed(2),
        c: myData.display?.c_residual || myData.totals.c.toFixed(2),
        ra, rb, rc,
        a_pct: myData.snapshotView.a_pct,
        da,
        a_gap_line: aGapLine,
        income: myData.snapshotView.income,
        cap_a: myData.snapshotView.cap_a,
        cap_b: myData.snapshotView.cap_b,
        cap_c: myData.snapshotView.cap_c,
        epf: myData.snapshotView.epf,
        travel: myData.snapshotView.travelMonthly,
        medical: myData.snapshotView.medicalMonthly,
        car_insurance: myData.snapshotView.carInsuranceMonthly,
        category_details: formatCategoryDetails(myData.categoryBreakdown)
      })
      
      // 根据时间范围替换标题
      let title = generateMonthTitle(range)
      
      await sendTelegramMessage(chatId, msg.replace(`📊 ${range} 数据总览`, title))
      return res.status(200).json({ ok: true })
    }
    if (st && st.flow === 'settings') {
      // settings callback entries
      if (data === 'set:nickname') { await setState(userId, 'settings', 'edit_nickname', {}); await sendTelegramMessage(chatId, messages.registration.nickname.prompt); return res.status(200).json({ ok: true }) }
      if (data === 'set:phone') { await setState(userId, 'settings', 'edit_phone', {}); await sendTelegramMessage(chatId, messages.registration.phone.prompt); return res.status(200).json({ ok: true }) }
      if (data === 'set:income') { await setState(userId, 'settings', 'edit_income', {}); await sendTelegramMessage(chatId, messages.registration.income.prompt); return res.status(200).json({ ok: true }) }
      if (data === 'set:a_pct') { await setState(userId, 'settings', 'edit_a_pct', {}); await sendTelegramMessage(chatId, messages.registration.budgetA.prompt); return res.status(200).json({ ok: true }) }
      if (data === 'set:b_pct') { await setState(userId, 'settings', 'edit_b_pct', {}); await sendTelegramMessage(chatId, messages.registration.budgetB.prompt); return res.status(200).json({ ok: true }) }
      if (data === 'set:travel') { await setState(userId, 'settings', 'edit_travel', {}); await sendTelegramMessage(chatId, messages.registration.travelBudget.prompt); return res.status(200).json({ ok: true }) }
      if (data === 'set:ins_med') { await setState(userId, 'settings', 'edit_ins_med', {}); await sendTelegramMessage(chatId, '请输入年度医疗保险金额（RM），例如 1200'); return res.status(200).json({ ok: true }) }
      if (data === 'set:ins_car') { await setState(userId, 'settings', 'edit_ins_car', {}); await sendTelegramMessage(chatId, '请输入年度车险金额（RM），例如 2400'); return res.status(200).json({ ok: true }) }
      if (data === 'set:branch') { await sendTelegramMessage(chatId, messages.registration.branch.prompt, { reply_markup: settingsBranchKeyboard() }); await setState(userId, 'settings', 'edit_branch', {}); return res.status(200).json({ ok: true }) }
      if (data === 'set:done') { 
        await clearState(userId)
        await sendTelegramMessage(chatId, '🎉 设置完成！所有修改已保存。\n\n现在你可以：\n• /record - 记录支出\n• /my - 查看统计报告\n• /settings - 再次修改资料\n\n💡 提示：下次修改设置时，记得点击"✅ 完成设置并保存所有修改"按钮来保存修改。')
        return res.status(200).json({ ok: true }) 
      }
    }
    if (data.startsWith('my:')) {
      const range = data.split(':')[1] || 'month'
      const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
      const base = `${url.protocol}//${url.host}`
      const r = await fetch(`${base}/api/my?userId=${userId}&range=${encodeURIComponent(range)}`)
      const myData = await r.json()
      if (!r.ok) { await sendTelegramMessage(chatId, '查询失败'); return res.status(200).json({ ok: true }) }
      const ra = myData.realtime?.a == null ? 'N/A' : myData.realtime.a
      const rb = myData.realtime?.b == null ? 'N/A' : myData.realtime.b
      const rc = myData.realtime?.c == null ? 'N/A' : myData.realtime.c
      const da = ra === 'N/A' ? 'N/A' : (Number(ra) - Number(myData.snapshotView.a_pct)).toFixed(0)
      const aGap = (Number(myData.snapshotView.cap_a) - Number(myData.totals.a)).toFixed(2)
      const aGapLine = Number(aGap) >= 0 ? `剩余额度 RM ${aGap}` : `已超出 RM ${Math.abs(Number(aGap)).toFixed(2)}`
      const msg = formatTemplate(messages.my.summary, {
        range,
        a: myData.display?.a || myData.totals.a.toFixed(2),
        b: myData.display?.b || myData.totals.b.toFixed(2),
        c: myData.display?.c_residual || myData.totals.c.toFixed(2),
        ra, rb, rc,
        a_pct: myData.snapshotView.a_pct,
        da,
        a_gap_line: aGapLine,
        income: myData.snapshotView.income,
        cap_a: myData.snapshotView.cap_a,
        cap_b: myData.snapshotView.cap_b,
        cap_c: myData.snapshotView.cap_c,
        epf: myData.snapshotView.epf,
        travel: Number(myData.snapshotView.travelMonthly || 0).toFixed(2),
        medical: Number(myData.snapshotView.medicalMonthly || 0).toFixed(2),
        car_insurance: Number(myData.snapshotView.carInsuranceMonthly || 0).toFixed(2),
        category_details: formatCategoryDetails(myData.categoryBreakdown)
      })
      
      // 根据时间范围替换标题
      let title = generateMonthTitle(range)
      
      // 保持相同的时间段选择按钮
      const keyboard = {
        inline_keyboard: [
          [
            { text: '📅 本月', callback_data: 'my:month' },
            { text: '📊 上月', callback_data: 'my:lastmonth' },
            { text: '🗓 本周', callback_data: 'my:week' }
          ]
        ]
      };
      
      // 使用 editMessageText 更新消息
      await editMessageText(chatId, cq.message.message_id, msg.replace(`📊 ${range} 数据总览`, title), { reply_markup: keyboard })
      await answerCallbackQuery(cq.id);
      return res.status(200).json({ ok: true })
    }
    if (data.startsWith('rec:') && (!st || st.flow !== 'record')) {
      await sendTelegramMessage(chatId, '请发送 /record 开始记录')
      return res.status(200).json({ ok: true })
    }
    if (data.startsWith('rec:grp:')) {
      const grp = data.split(':').pop()
      const groupLabel = grp === 'A' ? '生活开销' : grp === 'B' ? '学习投资' : '储蓄投资'
      await setState(userId, 'record', 'choose_category', { group: grp, groupLabel })
      await sendTelegramMessage(chatId, formatTemplate(messages.record.choose_category, { group: groupLabel }), { reply_markup: categoryKeyboard(grp) })
      return res.status(200).json({ ok: true })
    }
    if (data.startsWith('rec:cat:')) {
      const cat = data.split(':').pop()
      const payload = { ...(st.payload || {}), category: cat, group: (st.payload||{}).group, groupLabel: (st.payload||{}).groupLabel }
      await setState(userId, 'record', 'amount', payload)
      await sendTelegramMessage(chatId, messages.record.amount_prompt)
      return res.status(200).json({ ok: true })
    }
    if (data === 'rec:confirm') {
      if (st.step !== 'confirm') { await sendTelegramMessage(chatId, '状态已过期，请重新 /record'); await clearState(userId); return res.status(200).json({ ok: true }) }
      const payload = st.payload || {}
      // 调用后端 /api/record 执行入库 + 聚合 + streak
      const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
      const base = `${url.protocol}//${url.host}`
      const resp = await fetch(`${base}/api/record`, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({ userId: userId, category_group: payload.group, category_code: payload.category, amount: payload.amount, note: payload.note || '', ymd: new Date().toISOString().slice(0,10) })
      })
      if (!resp.ok) { await sendTelegramMessage(chatId, messages.record.save_failed); return res.status(200).json({ ok: true }) }
      await clearState(userId)
      await sendTelegramMessage(chatId,
        formatTemplate(messages.record.saved, { groupLabel: payload.groupLabel || payload.group, amount: Number(payload.amount).toFixed(2) }),
        { reply_markup: { inline_keyboard: [[{ text: messages.post.again, callback_data: 'rec:again' }, { text: messages.post.my, callback_data: 'my:month' }]] } }
      )
      return res.status(200).json({ ok: true })
    }
    if (data === 'rec:cancel') {
      await clearState(userId)
      await sendTelegramMessage(chatId, messages.record.canceled)
      return res.status(200).json({ ok: true })
    }
    
    if (data === 'rec:again') {
      await clearState(userId)
      await sendTelegramMessage(chatId, '🔄 请选择记录类别：', { reply_markup: groupKeyboard() })
      return res.status(200).json({ ok: true })
    }

    // 批量记录回调处理
    if (data.startsWith('batch:page:')) {
      const page = parseInt(data.split(':')[2])
      const st = await getState(userId)
      if (!st || st.flow !== 'batch' || st.step !== 'confirm') {
        await answerCallbackQuery(cq.id, '状态已过期，请重新开始批量记录')
        return res.status(200).json({ ok: true })
      }
      
      await setState(userId, 'batch', 'confirm', { ...st.payload, currentPage: page })
      await showBatchConfirmPage(chatId, st.payload.records, page, st.payload.groupLabel)
      await answerCallbackQuery(cq.id, `📄 第${page}页`)
      return res.status(200).json({ ok: true })
    }
    
    if (data === 'batch:edit') {
      const st = await getState(userId)
      if (!st || st.flow !== 'batch' || st.step !== 'confirm') {
        await answerCallbackQuery(cq.id, '状态已过期，请重新开始批量记录')
        return res.status(200).json({ ok: true })
      }
      
      await answerCallbackQuery(cq.id, '✏️ 修改功能开发中，请重新输入或直接确认')
      return res.status(200).json({ ok: true })
    }
    
    if (data === 'batch:delete') {
      const st = await getState(userId)
      if (!st || st.flow !== 'batch' || st.step !== 'confirm') {
        await answerCallbackQuery(cq.id, '状态已过期，请重新开始批量记录')
        return res.status(200).json({ ok: true })
      }
      
      await answerCallbackQuery(cq.id, '🗑️ 删除功能开发中，请重新输入或直接确认')
      return res.status(200).json({ ok: true })
    }
    
    if (data === 'batch:confirm') {
      const st = await getState(userId)
      if (!st || st.flow !== 'batch' || st.step !== 'confirm') {
        await answerCallbackQuery(cq.id, '状态已过期，请重新开始批量记录')
        return res.status(200).json({ ok: true })
      }
      
      const { records, group } = st.payload
      
      try {
        // 批量插入记录
        const recordsToInsert = records.map(record => ({
          user_id: userId,
          category_group: group,
          category_code: record.code,
          amount: record.amount,
          note: record.note || '',
          ymd: new Date().toISOString().slice(0, 10)
        }))
        
        const { error } = await supabase.from('records').insert(recordsToInsert)
        
        if (error) throw error
        
        // 成功提示
        const totalAmount = records.reduce((sum, r) => sum + r.amount, 0)
        await sendTelegramMessage(chatId, 
          `✅ 批量记录成功！\n\n💰 总计：RM ${totalAmount.toFixed(2)}\n📊 记录数：${records.length}笔\n\n🔄 继续记录：/record\n📊 查看统计：/my`, 
          { reply_markup: { inline_keyboard: [[{ text: '🔄 继续记录', callback_data: 'rec:again' }, { text: '📊 查看统计', callback_data: 'my:month' }]] } }
        )
        
        await clearState(userId)
        return res.status(200).json({ ok: true })
        
      } catch (error) {
        console.error('批量记录失败:', error)
        await sendTelegramMessage(chatId, '❌ 批量记录失败，请稍后重试')
        await clearState(userId)
        return res.status(200).json({ ok: true })
      }
    }
    
    if (data === 'batch:cancel') {
      await clearState(userId)
      await sendTelegramMessage(chatId, '❌ 已取消批量记录')
      return res.status(200).json({ ok: true })
    }

    // START flow: branch selection and finalize
    if (data.startsWith('start:branch:')) {
      const code = data.split(':').pop().toUpperCase()
      const st = await getState(userId)
      if (!st || st.flow !== 'start' || st.step !== 'branch') {
        await sendTelegramMessage(chatId, '状态已过期，请重新 /start')
        await clearState(userId)
        return res.status(200).json({ ok: true })
      }
      const payload = st.payload || {}
      // Persist
      await supabase.from('users').upsert({ id: userId, branch_code: code }, { onConflict: 'id' })
      await supabase.from('user_profile').upsert({
        user_id: userId,
        display_name: payload.nickname || update.callback_query?.from?.first_name || update.callback_query?.from?.username || 'user',
        chat_id: chatId,
        phone_e164: payload.phone_e164 || null,
        monthly_income: payload.income || 0,
        a_pct: payload.a_pct || 0,
        b_pct: payload.b_pct || 0,
        travel_budget_annual: payload.travel_budget_annual || 0,
        prev_month_spend: payload.prev_month_spend || 0
      })
      const yyyymm = new Date().toISOString().slice(0,7)
      await supabase.from('user_month_budget').upsert({ user_id: userId, yyyymm, income: payload.income || 0, a_pct: payload.a_pct || 0, b_pct: payload.b_pct || 0, epf_pct: 24 })
      await clearState(userId)
      const cPct = Math.max(0, 100 - (payload.a_pct || 0) - (payload.b_pct || 0))
      await sendTelegramMessage(chatId, formatTemplate(messages.registration.success, { budgetA: payload.a_pct||0, budgetB: payload.b_pct||0, budgetC: cPct, branch: code }))
      return res.status(200).json({ ok: true })
    }
    
    // SETTINGS flow: branch selection (when called from settings)
    if (data.startsWith('set:branch:')) {
      const code = data.split(':').pop().toUpperCase()
      // 直接更新分行信息
      await supabase.from('users').upsert({ id: userId, branch_code: code }, { onConflict: 'id' })
      // 显示更新后的设置摘要
      await showUpdatedSettingsSummary(chatId, userId)
      return res.status(200).json({ ok: true })
    }
    
    if (data.startsWith('hist:view:')) {
      const recordId = data.split(':').pop()
      await answerCallbackQuery(update.callback_query.id, '📋 查看记录详情')
      // 可以在这里显示记录的详细信息，或者直接不做任何操作
      return res.status(200).json({ ok: true })
    }
    
    if (data === 'hist:locked') {
      await answerCallbackQuery(update.callback_query.id, '🔒 此记录由系统自动生成，不可编辑。如需调整，请在设置中修改相关配置。')
      return res.status(200).json({ ok: true })
    }

    if (data.startsWith('history:')) {
      const range = data.split(':')[1] || 'month'
      const url = new URL(req.headers['x-forwarded-url'] || `https://${req.headers.host}${req.url}`)
      const base = `${url.protocol}//${url.host}`
      const r = await fetch(`${base}/api/records/list?userId=${userId}&range=${encodeURIComponent(range)}&page=1&pageSize=10`)
      const payload = await r.json()
      if (!r.ok) { await sendTelegramMessage(chatId, '查询失败'); return res.status(200).json({ ok: true }) }
      
      const grpName = (g) => g === 'A' ? '开销' : g === 'B' ? '学习' : '储蓄'
      const catLabel = (g, code) => {
        // 先检查是否为自动生成的分类代码
        if (code === 'ins_med_auto') return '医疗保险（月）'
        if (code === 'ins_car_auto') return '车险（月）'
        if (code === 'epf_auto') return 'EPF（月）'
        if (code === 'travel_auto') return '旅游基金（月）'
        
        // 然后检查常规分类
        const arr = GROUP_CATEGORIES[g] || []
        const found = arr.find(([c]) => c === code)
        return found ? found[1] : code
      }
      const list = (payload.rows || []).map(row => {
        const note = row.note && row.note !== 'Auto-post' ? ` · ${row.note}` : ''
        return `${row.ymd} · ${grpName(row.category_group)}/${catLabel(row.category_group, row.category_code)} · RM ${Number(row.amount).toFixed(2)}${note}`
      }).join('\n') || messages.history.noRecords
      const prev = Math.max(1, (payload.page || 1) - 1)
      const next = Math.min(payload.pages || 1, (payload.page || 1) + 1)
      const rowsKb = (payload.rows || []).map(row => generateHistoryButtons(row, grpName, catLabel))
      const kb = { inline_keyboard: [
        ...rowsKb,
        [ { text: '⬅️ 上一页', callback_data: `hist:page:${range}:${prev}` }, { text: '下一页 ➡️', callback_data: `hist:page:${range}:${next}` } ],
        [
          { text: '📅 本月', callback_data: 'history:month' },
          { text: '📊 上月', callback_data: 'history:lastmonth' },
          { text: '🗓 本周', callback_data: 'history:week' }
        ]
      ] }
      
      // 使用 editMessageText 更新消息
      await editMessageText(chatId, cq.message.message_id, `${messages.history.listHeader.replace('{range}', range)}\n${list}\n\n${messages.history.hint}`, { reply_markup: kb })
      await answerCallbackQuery(cq.id);
      return res.status(200).json({ ok: true })
    }
    if (data.startsWith('rec:batch:')) {
      const group = data.split(':').pop()
      const groupLabel = group === 'A' ? '生活开销' : group === 'B' ? '学习投资' : '储蓄投资'
      await setState(userId, 'batch', 'input', { group, groupLabel })
      await sendTelegramMessage(chatId, `🔄 批量记录模式\n\n请按以下格式输入记录（每行一条，最多20条）：\n\n格式：分类 金额 备注\n示例：\n食物 20 吃饭\n购物 15 买菜\n交通 8 公交\n\n💡 提示：\n• 系统会自动识别分类\n• 不匹配的分类会归到"其他"\n• 支持中文分类名称`, { reply_markup: { inline_keyboard: [[{ text: '❌ 取消', callback_data: 'batch:cancel' }]] } })
      return res.status(200).json({ ok: true })
    }
    if (data.startsWith('rec:cat:')) {
      const cat = data.split(':').pop()
      const payload = { ...(st.payload || {}), category: cat, group: (st.payload||{}).group, groupLabel: (st.payload||{}).groupLabel }
      await setState(userId, 'record', 'amount', payload)
      await sendTelegramMessage(chatId, messages.record.amount_prompt)
      return res.status(200).json({ ok: true })
    }
    return res.status(200).json({ ok: true })
  } catch (e) {
    console.error(e)
    return res.status(200).json({ ok: true })
  }
}


// 显示更新后的设置摘要和继续修改选项
async function showUpdatedSettingsSummary(chatId, userId) {
  try {
    // 获取最新的用户资料
    const { data: prof } = await supabase
      .from('user_profile')
      .select('display_name,phone_e164,monthly_income,a_pct,b_pct,travel_budget_annual,annual_medical_insurance,annual_car_insurance')
      .eq('user_id', userId)
      .maybeSingle()
    
    const { data: urow } = await supabase
      .from('users')
      .select('branch_code')
      .eq('id', userId)
      .maybeSingle()
    
    // 显示更新后的摘要
    const sumText = formatTemplate(messages.settings.summary, {
      nickname: prof?.display_name || '-',
      phone: prof?.phone_e164 || '-',
      income: (Number(prof?.monthly_income || 0)).toFixed(2),
      a_pct: Number(prof?.a_pct || 0).toFixed(2),
      b_pct: Number(prof?.b_pct || 0).toFixed(2),
      travel: (Number(prof?.travel_budget_annual || 0)).toFixed(2),
      ins_med: (Number(prof?.annual_medical_insurance || 0)).toFixed(2),
      ins_car: (Number(prof?.annual_car_insurance || 0)).toFixed(2),
      branch: (urow?.branch_code || '-')
    })
    
    // 提供继续修改的选项
    const kb = { inline_keyboard: [
      [ { text: messages.settings.fields.nickname, callback_data: 'set:nickname' }, { text: messages.settings.fields.phone, callback_data: 'set:phone' } ],
      [ { text: messages.settings.fields.income, callback_data: 'set:income' }, { text: messages.settings.fields.a_pct, callback_data: 'set:a_pct' } ],
      [ { text: messages.settings.fields.b_pct, callback_data: 'set:b_pct' }, { text: messages.settings.fields.travel, callback_data: 'set:travel' } ],
      [ { text: '年度医疗保险', callback_data: 'set:ins_med' }, { text: '年度车险', callback_data: 'set:ins_car' } ],
      [ { text: messages.settings.fields.branch, callback_data: 'set:branch' } ],
      [ { text: '✅ 完成设置并保存所有修改', callback_data: 'set:done' } ]
    ] }
    
    await sendTelegramMessage(chatId, `✅ 已更新！\n\n${sumText}\n\n${messages.settings.choose}\n\n💡 提示：修改完成后，请点击下方"✅ 完成设置并保存所有修改"按钮来结束设置流程。`, { reply_markup: kb })
    
    // 重置状态为选择模式，让用户可以继续修改
    await setState(userId, 'settings', 'choose', {})
  } catch (error) {
    console.error('Error showing updated settings summary:', error)
    // 如果出错，回退到原来的行为
    await clearState(userId)
    await sendTelegramMessage(chatId, messages.settings.updated)
  }
}

// 显示批量记录确认页面
async function showBatchConfirmPage(chatId, records, page, groupLabel) {
  const pageSize = 5
  const start = (page - 1) * pageSize
  const end = start + pageSize
  const pageRecords = records.slice(start, end)
  const totalPages = Math.ceil(records.length / pageSize)
  
  // 按分类分组显示
  const groupedRecords = {}
  pageRecords.forEach(record => {
    const categoryLabel = getCategoryLabel(record.code)
    if (!groupedRecords[categoryLabel]) {
      groupedRecords[categoryLabel] = []
    }
    groupedRecords[categoryLabel].push(record)
  })
  
  let message = `✅ 智能分类结果\n\n`
  
  for (const [category, items] of Object.entries(groupedRecords)) {
    message += `${category}：\n`
    items.forEach(item => {
      message += `• ${item.category} RM ${item.amount.toFixed(2)}${item.note ? ` (${item.note})` : ''}\n`
    })
    message += `\n`
  }
  
  message += `💰 本页总计：RM ${pageRecords.reduce((sum, r) => sum + r.amount, 0).toFixed(2)}\n`
  message += `📊 全部总计：RM ${records.reduce((sum, r) => sum + r.amount, 0).toFixed(2)} (${records.length}笔记录)\n`
  message += `📄 第${page}页 / 共${totalPages}页`
  
  const keyboard = []
  
  // 分页按钮
  if (totalPages > 1) {
    const pageRow = []
    if (page > 1) pageRow.push({ text: '⬅️ 上一页', callback_data: `batch:page:${page - 1}` })
    if (page < totalPages) pageRow.push({ text: '下一页 ➡️', callback_data: `batch:page:${page + 1}` })
    if (pageRow.length > 0) keyboard.push(pageRow)
  }
  
  // 操作按钮
  keyboard.push([
    { text: '✏️ 修改分类', callback_data: 'batch:edit' },
    { text: '🗑️ 删除记录', callback_data: 'batch:delete' }
  ])
  
  keyboard.push([
    { text: '✅ 确认全部', callback_data: 'batch:confirm' },
    { text: '❌ 取消', callback_data: 'batch:cancel' }
  ])
  
  await sendTelegramMessage(chatId, message, { reply_markup: { inline_keyboard: keyboard } })
}

// 获取分类标签
function getCategoryLabel(code) {
  // 直接使用现有的分类系统
  for (const [group, categories] of Object.entries(GROUP_CATEGORIES)) {
    const category = categories.find(([c]) => c === code)
    if (category) {
      return category[1] // 返回中文标签
    }
  }
  
  // 如果找不到，尝试从所有分类中查找
  for (const categories of Object.values(GROUP_CATEGORIES)) {
    const category = categories.find(([c]) => c === code)
    if (category) {
      return category[1]
    }
  }
  
  // 最后的fallback：返回code本身，但确保它是有效的
  console.warn(`未找到分类标签: ${code}`)
  return code
}

// 生成月份标题
function generateMonthTitle(range) {
  const now = new Date()
  let targetDate = new Date()
  
  if (range === 'month') {
    // 本月
    targetDate = now
  } else if (range === 'lastmonth') {
    // 上月
    targetDate = new Date(now.getFullYear(), now.getMonth() - 1, 1)
  } else if (range === 'week') {
    // 本周
    targetDate = now
  } else if (range === 'today') {
    // 今日
    targetDate = now
  }
  
  const month = targetDate.getMonth() + 1
  const monthNames = ['', '1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月']
  
  if (range === 'month') return `📊 ${monthNames[month]}统计`
  else if (range === 'lastmonth') return `📊 ${monthNames[month]}统计`
  else if (range === 'week') return `📊 本周统计`
  else if (range === 'today') return `📊 今日统计`
  else return `📊 ${range}统计`
}

